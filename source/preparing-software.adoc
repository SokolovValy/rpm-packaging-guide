[[preparing-software-for-packaging]]
= Подготовка программного обеспечения для упаковки

Эта глава посвящена исходному коду и созданию программного обеспечения, которые являются необходимой основой для RPM-упаковщика.

[[what-is-source-code]]
== Что такое Исходный код?

**Исходный код ** - это понятные для человека инструкции к компьютеру, в которых описывается, как выполнить вычисления. Исходный код выражается с помощью
ifdef::community[https://en.wikipedia.org/wiki/Programming_language[языка программирования]]
ifdef::rhel[programming language]
.

В этом руководстве представлены три версии  ``Hello World`` программы, каждая из которых написана на разных языках программирования. Программы, написанные на этих трех разных языках, упаковываются по-разному и охватывают три основных варианта использования RPM-упаковщика.

NOTE: Существуют тысячи языков программирования. В этом документе представлены только три из них, но их достаточно для концептуального обзора.

``Hello World`` написано на https://www.gnu.org/software/bash/[bash]:

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

``Hello World`` написано на https://www.python.org/[Python]:

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

``Hello World`` написано на
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
:

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----

Целью каждой из трех программ является вывод ``Hello World`` в
 командной строке.

NOTE: Знание того, как программировать, не обязательно для упаковщика программного обеспечения, но полезно.

[[how-programs-are-made]]
== Как создаются программы

Существует множество методов, с помощью которых читаемый человеком исходный код становится машинным кодом - инструкциями, которым компьютер следует для фактического выполнения программы. Однако все методы можно свести к этим трем:

1. Программа изначально скомпилирована..
2. Программа интерпретируется с помощью необработанной интерпретации.
3. Программа интерпретируется путем байтовой компиляции.

[[natively-compiled-code]]
=== Изначально скомпилированный код

**Изначально скомпилированное** программное обеспечение - это программное обеспечение, написанное на языке программирования, которое компилируется в машинный код с результирующим двоичным исполняемым файлом. Такое программное обеспечение можно запускать автономно.

Пакеты RPM, созданные таким образом, зависят от
ifdef::community[https://en.wikipedia.org/wiki/Microarchitecture[архитектуры]]
ifdef::rhel[architecture]
 Это означает, что если вы скомпилируете такое программное обеспечение на компьютере, использующем 64-разрядный (x86_64) процессор AMD или Intel, оно не будет выполняться на 32-разрядном (x86) процессоре AMD или Intel. В названии результирующего пакета будет указана архитектура.

[[interpreted-code]]
=== Интерпретируемый код

Некоторые языки программирования, такие как https://www.gnu.org/software/bash/[bash] или https://www.python.org/[Python], не компилируются в машинный код. Вместо этого исходный код их программ выполняется шаг за шагом, без предварительных преобразований,
ifdef::community[https://en.wikipedia.org/wiki/Interpreter_%28computing%29[языковым интерпритатором]]
ifdef::rhel[Language Interpreter]
или языковой виртуальной машиной.

Программное обеспечение, написанное полностью на интерпретируемых языках программирования, не зависит от
ifdef::community[https://en.wikipedia.org/wiki/Microarchitecture[архитектуры]]
ifdef::rhel[architecture]
Следовательно, результирующий пакет RPM будет иметь строку ``noarch`` в своем названии.

Существует два типа интерпретируемых языков: *байт-скомпилированные* и *необработанные интерпретируемые*. Процесс сборки программ для этих двух типов отличается.

//Interpreted languages are either *byte-compiled* or *raw-interpreted*. These two
//types differ in program build process and in packaging procedure.

==== Программы с интерпретацией Raw
Программы на языке с интерпретацией Raw вообще не нужно компилировать, они выполняются непосредственно интерпретатором.

==== Программы, скомпилированные в байтах
Языки, скомпилированные в байтах, должны быть скомпилированы в байтовый код, который затем выполняется виртуальной машиной языка.e.

NOTE: Некоторые языки предоставляют выбор: они могут быть интерпретированы в формате raw или скомпилированы в байтах.

// This difference reflects on the packaging procedure. Some languages give a choice: they can be raw-interpreted or byte-compiled.

// Software written entirely in interpreted programming languages is not https://en.wikipedia.org/wiki/Microarchitecture[architecture]-specific. Hence, the resulting RPM Package will have string ``noarch`` in its name.

[[building-software-from-source]]
== Создание программного обеспечения из исходного кода

В этом разделе объясняется сборка программного обеспечения на основе его исходного кода.

* Для программного обеспечения, написанного на скомпилированных языках, исходный код проходит процесс *сборки*, создавая машинный код. Этот процесс, обычно называемый *компиляцией* или *переводом*, различается для разных языков. Полученное встроенное программное обеспечение может быть *запущено* или "*выполнено*", что заставляет компьютер выполнять задачу, указанную программистом.
* Для программного обеспечения, написанного на необработанных интерпретируемых языках, исходный код не создается, а выполняется напрямую.
* Для программного обеспечения, написанного на интерпретируемых языках с байтовой компиляцией, исходный код компилируется в байтовый код, который затем выполняется виртуальной машиной языка.

[[natively-compiled-code-building-software-from-source]]
=== Изначально скомпилированный код

В этом примере вы создадите ``cello.c`` программу, написанную на языке
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
в исполняемый файл.

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----

[[manual-building]]
==== Ручная сборка

Вызовите компилятор
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
из коллекции компиляторов GNU  (https://gcc.gnu.org/[GCC]) чтобы скомпилировать исходный код в двоичный файл:

[source,bash]
----
gcc -g -o cello cello.c

----

Выполните результирующий двоичный файл вывода``cello``.

[source,bash]
----
$ ./cello
Hello World

----

Вот и все. Вы создали и запустили изначально скомпилированное программное обеспечение из исходного кода.

==== Автоматическая сборка

Вместо того, чтобы создавать исходный код вручную, вы можете автоматизировать сборку. Это обычная практика, используемая в крупномасштабном программном обеспечении. Автоматизация сборки осуществляется путем создания  ``Makefile`` и затем запускаем
http://www.gnu.org/software/make/[GNU ``make``] utility.

Чтобы настроить автоматическую сборку, создайте файл с именем  ``Makefile`` в том же каталоге, что и``cello.c``:

``Makefile``

[source,makefile]
----
cello:
        gcc -g -o cello cello.c

clean:
        rm cello

----

Теперь, чтобы собрать программу, просто запустите ``make``:

[source,bash]
----
$ make
make: 'cello' is up to date.

----

Посколько сборка уже создана, ``make clean`` очистит её, а затем снова запустит ``make``:

[source,bash]
----
$ make clean
rm cello

$ make
gcc -g -o cello cello.c

----

Опять же, попытка сборки после другой сборки ничего не даст:

[source,bash]
----
$ make
make: 'cello' is up to date.

----

Наконец, программа выполнится:

[source,bash]
----
$ ./cello
Hello World

----

Теперь вы скомпилировали программу как вручную, так и с помощью инструмента сборки.


[[interpreted-code-building-software-from-source]]
=== Интерпретируемый код


Следующие два примера демонстрируют байтовую компиляцию программы, написанной на
https://www.python.org/[Python] и raw - интерпретация программы, написанной на
https://www.gnu.org/software/bash/[bash].

[NOTE]
====
В двух приведенных ниже примерах``#!`` строка в верхней части файла называется 
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
и не является частью исходного кода языка программирования.

ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
позволяет использовать текстовый файл в качестве исполняемого файла: загрузчик системной программы анализирует строку, содержащую *shebang*, чтобы получить путь к двоичному исполняемому файлу, который затем используется в качестве интерпретатора языка программирования.
====

[[byte-compiled-code]]
==== Скомпилированный в байт-код

В этом примере вы скомпилируете  ``pello.py`` - программу, написанную на Python в виде байт-кода, который затем выполняется виртуальной машиной на языке Python. Исходный код Python также может быть интерпретирован в формате raw, но версия, скомпилированная в байтах, быстрее. Следовательно, упаковщики RPM предпочитают упаковывать версию, скомпилированную в байтах, для распространения среди конечных пользователей.

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

Процедура байтовой компиляции программ отличается для разных языков. Это зависит от языка, виртуальной машины языка, а также инструментов и процессов, используемых с этим языком.

NOTE: https://www.python.org/[Python] часто компилируется в бай-код, но не так, как описано здесь. Следующая процедура направлена не на то, чтобы соответствовать стандартам сообщества, а на то, чтобы быть простой. Для получения практических рекомендаций по Python см. раздел
https://docs.python.org/2/library/distribution.html[Упаковка и распространение программного обеспечения].

Байтовая компиляция ``pello.py``:

[source,bash]
----
$ python -m compileall pello.py

$ file pello.pyc
pello.pyc: python 2.7 byte-compiled

----

Выполните байт-код в ``pello.pyc``:

[source,bash]
----
$ python pello.pyc
Hello World

----

[[raw-interpreted]]
==== Необработанный интерпретируемый код

In this example, you will raw-interpret the ``bello`` program written in the
https://www.gnu.org/software/bash/[bash] shell built-in language.

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

Programs written in shell scripting languages, like _bash_, are raw-interpreted.
Hence, you only need to make the file with source code executable and run it:

[source,bash]
----
$ chmod +x bello
$ ./bello
Hello World

----

[[patching-software]]
== Patching Software

A **patch** is source code that updates other source code. It is formatted as a
__diff__, because it represents what is different between two versions of text.
A __diff__ is created using the ``diff`` utility, which is then applied to the
source code using the http://savannah.gnu.org/projects/patch/[patch] utility.

NOTE: Software developers often use Version Control Systems such as
https://git-scm.com/[git] to manage their code base. Such tools provide their
own methods of creating diffs or patching software.

In the following example, we create a patch from the original source code using
``diff`` and then apply it using ``patch``. Patching is used in a later section
when creating an RPM, xref:working-with-spec-files[].

How is patching related to RPM packaging? In packaging, instead of simply
modifying the original source code, we keep it, and use patches on it.

To create a patch for ``cello.c``:

. Preserve the original source code:
+
[source,bash]
----
$ cp cello.c cello.c.orig

----
+
This is a common way to preserve the original source code file.
+
. Change ``cello.c``:
+
[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World from my very first patch!\n");
    return 0;
}

----
+
. Generate a patch using the ``diff`` utility:
+
NOTE: We use several common arguments for the ``diff`` utility. For more
information on them, see the ``diff`` manual page.
+
[source,diff]
----
$ diff -Naur cello.c.orig cello.c
--- cello.c.orig        2016-05-26 17:21:30.478523360 -0500
+++ cello.c     2016-05-27 14:53:20.668588245 -0500
@@ -1,6 +1,6 @@
 #include<stdio.h>

 int main(void){
-    printf("Hello World!\n");
+    printf("Hello World from my very first patch!\n");
     return 0;
 }
----
+
Lines starting with a ``-`` are removed from the original source code and
replaced with the lines that start with ``+``.
+
. Save the patch to a file:
+
[source,bash]
----
$ diff -Naur cello.c.orig cello.c > cello-output-first-patch.patch
----
+
. Restore the original ``cello.c``:
+
[source,bash]
----
$ cp cello.c.orig cello.c
----
+
We retain the original ``cello.c``, because when an RPM is built, the original
file is used, not a modified one. For more information, see
xref:working-with-spec-files[].

To patch ``cello.c`` using ``cello-output-first-patch.patch``, redirect the
patch file to the ``patch`` command:

[source,bash]
----
$ patch < cello-output-first-patch.patch
patching file cello.c
----

The contents of ``cello.c`` now reflect the patch:

[source,bash]
----
$ cat cello.c
#include<stdio.h>

int main(void){
    printf("Hello World from my very first patch!\n");
    return 0;
}
----

To build and run the patched ``cello.c``:

[source,bash]
----
$ make clean
rm cello

$ make
gcc -g -o cello cello.c

$ ./cello
Hello World from my very first patch!
----

You have created a patch, patched a program, built the patched program, and run
it.

[[installing-arbitrary-artifacts]]
== Installing Arbitrary Artifacts

A big advantage of
ifdef::community[https://en.wikipedia.org/wiki/Linux[Linux]]
ifdef::rhel[Linux]
and other Unix-like systems is the
ifdef::community[https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Filesystem Hierarchy Standard]]
ifdef::rhel[Filesystem Hierarchy Standard]
(FHS). It specifies in which directory which files should be located. Files installed from
the RPM packages should be placed according to FHS. For example, an executable
file should go into a directory that is in the system
ifdef::community[https://en.wikipedia.org/wiki/PATH_%28variable%29[PATH]]
ifdef::rhel[PATH]
variable.

In the context of this guide, an __Arbitrary Artifact__ is anything installed
from an RPM to the system. For RPM and for the system it can be a script, a
binary compiled from the package's source code, a pre-compiled binary, or any
other file.

We will explore two popular ways of placing __Arbitrary Artifacts__ in the
system: using the ``install`` command and using the ``make install`` command.

[[install-command]]
=== Using the install command

Sometimes using build automation tooling such as
http://www.gnu.org/software/make/[GNU make] is not optimal - for example, if the
packaged program is simple and does not need extra overhead. In these cases,
packagers often use the ``install`` command (provided to the system by
http://www.gnu.org/software/coreutils/coreutils.html[coreutils]), which places
the artifact to the specified directory in the filesystem with a specified set
of permissions.

The example below is going to use the ``bello`` file that we had previously
created as the arbitrary artifact subject to our installation method. Note that
you will either need http://www.sudo.ws/[sudo] permissions or run this command
as root excluding the ``sudo`` portion of the command.

In this example, ``install`` places the ``bello`` file into ``/usr/bin`` with
permissions common for executable scripts:

[source,bash]
----
$ sudo install -m 0755 bello /usr/bin/bello

----

Now ``bello`` is in a directory that is listed in the
ifdef::community[https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH]]
ifdef::rhel[$PATH]
variable. Therefore,
you can execute ``bello`` from any directory without specifying its full path:

[source,bash]
----
$ cd ~

$ bello
Hello World

----

[[make-install]]
=== Using the make install command

A popular automated way to install built software to the system is to use the
``make install`` command. It requires you to specify how to install the
arbitrary artifacts to the system in the ``Makefile``.

NOTE: Usually ``Makefile`` is written by the developer and not by the packager.

Add the ``install`` section to the ``Makefile``:

``Makefile``

[source,makefile]
----
cello:
        gcc -g -o cello cello.c

clean:
        rm cello

install:
        mkdir -p $(DESTDIR)/usr/bin
        install -m 0755 cello $(DESTDIR)/usr/bin/cello

----

The https://www.gnu.org/software/make/manual/html_node/DESTDIR.html[$(DESTDIR)]
variable is a http://www.gnu.org/software/make/[GNU make] built-in and is
commonly used to specify installation to a directory different than the root
directory.

Now you can use ``Makefile`` not only to build software, but also to install it
to the target system.

To build and install the ``cello.c`` program:

[source,bash]
----
$ make
gcc -g -o cello cello.c

$ sudo make install
install -m 0755 cello /usr/bin/cello

----

Now ``cello`` is in a directory that is listed in the
ifdef::community[https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH]]
ifdef::rhel[$PATH]
variable. Therefore,
you can execute ``cello`` from any directory without specifying its full path:

[source,bash]
----
$ cd ~

$ cello
Hello World

----

You have installed a build artifact into a chosen location on the system.

[[preparing-source-code-for-packaging]]
== Preparing Source Code for Packaging

NOTE: The code created in this section can be found
https://github.com/redhat-developer/rpm-packaging-guide/tree/master/example-code[here].

Developers often distribute software as compressed archives of source code,
which are then used to create packages. In this section, you will create such
compressed archives.

NOTE: Creating source code archives is not normally done by the RPM Packager,
but by the developer. The packager works with a ready source code archive.

Software should be distributed with a
ifdef::community[https://en.wikipedia.org/wiki/Software_license[software license]]
ifdef::rhel[software license]
. For the
examples, we will use the
https://www.gnu.org/licenses/quick-guide-gplv3.html[GPLv3] license. The license
text goes into the ``LICENSE`` file for each of the example programs. An RPM
packager needs to deal with license files when packaging.

For use with the following examples, create a ``LICENSE`` file:

[source,bash]
----
$ cat /tmp/LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

----

[[putting-source-code-into-tarball]]
== Putting Source Code into Tarball

In the examples below, we put each of the three ``Hello World`` programs into a
https://www.gnu.org/software/gzip/[gzip]-compressed tarball. Software is often
released this way to be later packaged for distribution.

[[bello]]
=== bello

The __bello__ project implements ``Hello World`` in
https://www.gnu.org/software/bash/[bash]. The implementation only contains the
``bello`` shell script, so the resulting ``tar.gz`` archive will have only one
file apart from the ``LICENSE`` file. Let us assume that this is version ``0.1``
of the program.

Prepare the __bello__ project for distribution:

. Put the files into a single directory:
+
[source,bash]
----
$ mkdir /tmp/bello-0.1

$ mv ~/bello /tmp/bello-0.1/

$ cp /tmp/LICENSE /tmp/bello-0.1/

----

. Create the archive for distribution and move it to ``~/rpmbuild/SOURCES/``:
+
[source,bash]
----
$ cd /tmp/

$ tar -cvzf bello-0.1.tar.gz bello-0.1
bello-0.1/
bello-0.1/LICENSE
bello-0.1/bello

$ mv /tmp/bello-0.1.tar.gz ~/rpmbuild/SOURCES/

----

[[pello]]
=== pello

The __pello__ project implements ``Hello World`` in
https://www.python.org/[Python]. The implementation only contains the
``pello.py`` program, so the resulting ``tar.gz`` archive will have only one
file apart from the ``LICENSE`` file. Let us assume that this is version
``0.1.1`` of the program.

Prepare the __pello__ project for distribution:

. Put the files into a single directory:
+
[source,bash]
----
$ mkdir /tmp/pello-0.1.1

$ mv ~/pello.py /tmp/pello-0.1.1/

$ cp /tmp/LICENSE /tmp/pello-0.1.1/

----

. Create the archive for distribution and move it to ``~/rpmbuild/SOURCES/``:
+
[source,bash]
----
$ cd /tmp/

$ tar -cvzf pello-0.1.1.tar.gz pello-0.1.1
pello-0.1.1/
pello-0.1.1/LICENSE
pello-0.1.1/pello.py

$ mv /tmp/pello-0.1.1.tar.gz ~/rpmbuild/SOURCES/

----

[[cello]]
=== cello

The __cello__ project implements ``Hello World`` in
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
. The implementation only contains the ``cello.c`` and
``Makefile`` files, so the resulting ``tar.gz`` archive will have only two files
apart from the ``LICENSE`` file. Let us assume that this is version ``1.0`` of
the program.

Note that the ``patch`` file is not distributed in the archive with the program.
The RPM Packager applies the patch when the RPM is built. The patch will be
placed in the ``~/rpmbuild/SOURCES/`` directory alongside the ``.tar.gz``.

Prepare the __cello__ project for distribution:


. Put the files into a single directory:
+
[source,bash]
----
$ mkdir /tmp/cello-1.0

$ mv ~/cello.c /tmp/cello-1.0/

$ mv ~/Makefile /tmp/cello-1.0/

$ cp /tmp/LICENSE /tmp/cello-1.0/

----

. Create the archive for distribution and move it to ``~/rpmbuild/SOURCES/``:
+
[source,bash]
----
$ cd /tmp/

$ tar -cvzf cello-1.0.tar.gz cello-1.0
cello-1.0/
cello-1.0/Makefile
cello-1.0/cello.c
cello-1.0/LICENSE

$ mv /tmp/cello-1.0.tar.gz ~/rpmbuild/SOURCES/

----

. Add the patch:
+
[source,bash]
----
$ mv ~/cello-output-first-patch.patch ~/rpmbuild/SOURCES/

----

Now the source code is ready for packaging into an RPM.
