[[packaging-software]]
= Программное обеспечение для упаковки

ifdef::community[]
В этом руководстве объясняется, как упаковывать RPM для дистрибутивов Linux семейства Red Hat, в первую очередь:

*   https://getfedora.org/[Fedora]
*   https://www.centos.org/[CentOS]
*   https://www.redhat.com/en/technologies/linux-platforms[Red Hat Enterprise Linux] (https://www.redhat.com/en/technologies/linux-platforms[RHEL])
endif::community[]

ifdef::rhel[]
В этом руководстве объясняется, как упаковывать RPM для дистрибутивов Linux семейства Red Hat, в первую очередь:
https://www.redhat.com/en/technologies/linux-platforms[Red Hat Enterprise Linux]
(RHEL).
endif::rhel[]

ifdef::community[]
Эти дистрибутивы используют формат упаковки http://rpm.org/[RPM].

Хотя эти дистрибутивы являются целевой средой, данное руководство в основном применимо ко всем дистрибутивам, основанным на 
https://en.wikipedia.org/wiki/List_of_Linux_distributions#RPM-based[RPM based]
.  Однако инструкции должны быть адаптированы для функций, специфичных для дистрибутива, таких как обязательные элементы установки, рекомендации или макросы.
endif::community[]

ifdef::rhel[]
While RHEL is the target environment, this guide is mostly applicable to all RPM
based distributions. However, the instructions need to be adapted for
distribution-specific features, such as prerequisite installation items,
guidelines, or macros.
endif::rhel[]

В этом руководстве не предполагается никаких предварительных знаний об упаковке программного обеспечения для любой операционной системы, Linux или какой-либо другой.

ifdef::community[]
NOTE: Если вы не знаете, что такое программный пакет или дистрибутив GNU/Linux, рассмотрите возможность изучения некоторых статей на темы
https://en.wikipedia.org/wiki/Linux[Linux] и
https://en.wikipedia.org/wiki/Package_manager[Package Managers].
endif::community[]

[[rpm-packages]]
== RPM Пакеты

В этом разделе рассматриваются основы формата упаковки RPM. Дополнительные сведения смотри в разделе
xref:advanced-topics[].

[[what-is-an-rpm]]
=== Что такое RPM?

Пакет RPM - это просто файл, содержащий другие файлы и информацию о них, необходимую системе. В частности, пакет RPM состоит из архива
ifdef::community[https://en.wikipedia.org/wiki/Cpio[cpio]]
ifdef::rhel[cpio]
, который содержит файлы, и заголовка RPM, который содержит метаданные о пакете. Диспетчер пакетов ``rpm`` использует эти метаданные для определения зависимостей, места установки файлов и другой информации.

Существует два типа пакетов RPM:

* исходник RPM (SRPM)
* бинарный RPM

SRPMs и двоичные RPMs имеют общий формат файла и инструментарий, но имеют разное содержимое и служат разным целям. SRPM содержит исходный код, при необходимости исправления к нему и файл спецификации, в котором описывается, как встроить исходный код в двоичный RPM. Бинарный RPM содержит двоичные файлы, созданные из исходных текстов и патчей.

[[rpm-packaging-tools]]
=== RPM Packaging Tools

Пакет``rpmdevtools``, установленный на этпе xref:prerequisites[], provides предоставляет несколько утилит для упаковки RPM. Чтобы перечислить эти утилиты, запустите:

[source,bash]
----
$ rpm -ql rpmdevtools | grep bin

----

Для получения дополнительной информации о вышеуказанных утилитах см. их страницы руководства или диалоговые окна справки.

[[rpm-packaging-workspace]]
=== Рабочее пространство для упаковки RPM

Чтобы настроить макет каталога, который является рабочей областью упаковки RPM, используйте утилиту ``rpmdev-setuptree``:

[source,bash]
----
$ rpmdev-setuptree

$ tree ~/rpmbuild/
/home/user/rpmbuild/
|-- BUILD
|-- RPMS
|-- SOURCES
|-- SPECS
`-- SRPMS`

5 directories, 0 files

----

Созданные каталоги служат следующим целям:

[cols="20%,80%"]
|====
| Каталог | Назначение
| BUILD     | При сборке пакетов здесь создаются различные каталоги     ``%buildroot``. Это полезно для расследования неудачной сборки, если выходные данные журналов не содержат достаточной информации.
| RPMS      | Двоичные RPM создаются здесь, в подкаталогах для разных архитектур, например, в подкаталогах``x86_64`` и ``noarch``.
| SOURCES   | Здесь упаковщик помещает сжатые архивы исходного кода и патчи. Команда ``rpmbuild`` ищет их здесь.
| SPECS     | Упаковщик помещает сюда файлы спецификаций..
| SRPMS     | Когда rpmbuild используется для построения SRPM вместо двоичного RPM, результирующий SRPM создается здесь.
|====

[[what-is-a-spec-file]]
=== Что такое SPEC файл?

Файл спецификации можно рассматривать как "рецепт", который утилита ``rpmbuild`` использует для фактической сборки RPM. Он сообщает системе сборки, что делать, определяя инструкции в серии разделов. Разделы определены в __Преамбуле__ и в __Основной части__. __Преамбула__ содержит ряд элементов метаданных, которые используются в __Основной части__. Тело содержит основную часть инструкций.
[[preamble-items]]
==== Пункты преамбулы

В этой таблице перечислены элементы, используемые в разделе преамбулы файла спецификации RPM:

[cols="30%,70%"]
|====
| SPEC Директива   | Определение
| ``Name``          | Базовое имя пакета, которое должно совпадать с именем файла спецификации.
| ``Version``       | Версия upstream-кода.
| ``Release``       | Релиз пакета используется для указания номера сборки пакета при данной версии upstream-кода. Как правило, установите начальное значение равным 1%{?dist} и увеличивайте его с каждым новым выпуском пакета. Сбросьте значение до 1 при создании новой версии программного обеспечения.
| ``Summary``       | Краткое, в одну строку, описание пакета.
| ``License``       | Лицензия на упаковываемое программное обеспечение.
ifdef::community[]
Fля пакетов, распространяемых в дистрибутивах сообщества, таких как https://getfedora.org/[Fedora], это должна быть лицензия с открытым исходным кодом, соответствующая рекомендациям по лицензированию конкретного дистрибутива.
endif::community[]
| ``URL``           | Полный URL-адрес для получения дополнительной информации о программе. Чаще всего это веб-сайт upstream-проекта для упаковываемого программного обеспечения.
| ``Source0``       | Путь или URL-адрес к сжатому архиву исходного кода (не исправленный, исправления обрабатываются в другом месте). Этот раздел должен указывать на доступное и надежное хранилище архива, например, на upstream-страницу, а не на локальное хранилище упаковщика. При необходимости можно добавить дополнительные исходные директивы, каждый раз увеличивая их количество, например: Source1, Source2, Source3 и так далее.
| ``Patch0``        | Название первого исправления, которое при необходимости будет применено к исходному коду. При необходимости можно добавить дополнительные директивы PatchX, увеличивая их количество каждый раз, например: Patch1, Patch2, Patch3 и так далее.
| ``BuildArch``     | Если пакет не зависит от архитектуры, например, если он полностью написан на интерпретируемом языке программирования, установите для этого значение ``BuildArch: noarch``. Если этот параметр не задан, пакет автоматически наследует архитектуру компьютера, на котором он построен, например ``x86_64``.
| ``BuildRequires`` | Разделенный запятыми или пробелами список пакетов, необходимых для сборки программы, написанной на скомпилированном языке. Может быть несколько записей ``BuildRequires``, каждая в отдельной строке в файле спецификации. 
| ``Requires`` | Разделенный запятыми или пробелами список пакетов, необходимых программному обеспечению для запуска после установки. Может быть несколько записей ``Requires``, каждая в отдельной строке в файле спецификации.
| ``ExcludeArch``   | Если часть программного обеспечения не может работать на определенной архитектуре процессора, вы можете исключить эту архитектуру здесь.
|====

Директивы ``Name``, ``Version`` и ``Release`` содержат имя файла пакета RPM. Разработчики пакетов RPM и системные администраторы часто называют эти три директивы **N-V-R** или **NVR**, поскольку имена файлов пакетов RPM имеют формат ``NAME-VERSION-RELEASE``.


Вы можете получить пример ``NAME-VERSION-RELEASE``, выполнив запрос с использованием ``rpm`` для конкретного пакета:

[source,bash]
----
$ rpm -q python
python-2.7.5-34.el7.x86_64

----

Здесь ``python`` - это имя пакета, ``2.7.5`` - версия, а ``34.el7`` - релиз. Последний маркер ``x86_64`` - сведения об архитектуре.
В отличие от NVR, маркер архитектуры не находится под прямым управлением RPM упаковщика, а определяется средой сборки ``rpmbuild``. Исключением из этого правила является архитектурно-независимый пакет ``noarch``.

[[body-items]]
==== Составляющие основной части

В этой таблице перечислены элементы, используемые в разделе Body (Тело, основная часть) файла спецификации RPM:

[cols="20%,80%"]
|====
| SPEC Директива   | Определение
| ``%description`` | Полное описание программного обеспечения, входящего в комплект поставки RPM. Это описание может занимать несколько строк и может быть разбито на абзацы.
| ``%prep``        | Команда или серия команд для подготовки программного обеспечения к сборке, например, распаковка архива в Source0. Эта директива может содержать сценарий оболочки.
| ``%build``       | Команда или серия команд для фактической сборки программного обеспечения в машинный код (для скомпилированных языков) или байт-код (для некоторых интерпретируемых языков).
| ``%install``     | Команда или серия команд для копирования требуемых артефактов сборки из ``%builddir`` (где происходит сборка) в``%buildroot`` каталог (который содержит структуру каталогов с файлами, подлежащими упаковке). Обычно это означает копирование файлов из ``~/rpmbuild/BUILD`` в ``~/rpmbuild/BUILDROOT`` и создание необходимых каталогов ``~/rpmbuild/BUILDROOT``.  Это выполняется только при создании пакета, а не при установке пакета конечным пользователем. Подробности см в разделе xref:working-with-spec-files[Работа со SPEK файлом].
| ``%check``       | Команда или серия команд для тестирования программного обеспечения. Обычно это включает в себя такие вещи, как модульные тесты.
| ``%files``       | Список файлов, которые будут установлены в системе конечного пользователя.
| ``%changelog``   | Запись изменений, произошедших с пакетом между различными ``Version`` или ``Release`` сборками.
|====

[[advanced-items]]
==== Дополнительные элементы 

Файл спецификации также может содержать дополнительные элементы. Например, файл спецификации может содержать __скриптлеты_ и __триггеры__. Они вступают в силу в разные моменты процесса установки в системе конечного пользователя (не в процессе сборки).

Дополнительную информацию см.  xref:triggers-and-scriptlets[Триггеры и скриптлеты].

[[buildroots]]
=== BuildRoots

В контексте упаковки RPM "buildroot" - это среда 
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
Это означает, что артефакты сборки размещаются здесь с использованием той же иерархии файловой системы, что и в системе конечного пользователя, при этом "buildroot" выступает в качестве корневого каталога. Размещение артефактов сборки должно соответствовать стандарту иерархии файловой системы системы конечного пользователя.

Файлы в "buildroot" позже помещаются в архив
ifdef::community[https://en.wikipedia.org/wiki/Cpio[cpio]]
ifdef::rhel[cpio]
который становится основной частью RPM. Когда RPM устанавливается в системе конечного пользователя, эти файлы извлекаются в корневом каталоге, сохраняя правильную иерархию.

[NOTE]
====
// In past, it was either recommended to define the `%buildroot` macro in the `~/.rpmmacros` directory or to define the `BuildRoot` tag directly in a SPEC file. 
Начиная с выпуска Red Hat Enterprise Linux 6, программа `rpmbuild` меет свои собственные значения по умолчанию. Поскольку переопределение этих значений по умолчанию приводит к ряду проблем, Red Hat не рекомендует определять собственное значение этого макроса. Вы можете использовать макрос 
`%{buildroot}`  с параметрами по умолчанию из каталога `rpmbuild`.
====

[[rpm-macros]]
=== RPM Макросы

https://rpm-software-management.github.io/rpm/manual/macros.html[Макрос RPM] - это прямая замена текста, которая может быть условно назначена на основе необязательной оценки оператора при использовании определенной встроенной функциональности. Это означает, что Вы можете заставить RPM выполнять замены текста за Вас.

Это полезно, например, при многократной ссылке на __Version__ упакованного программного обеспечения в файле спецификации. Вы определяете __Version__ только один раз - в макросе ``%{version}``. Затем используйте ``%{version}`` во всем файле спецификации. Каждое вхождение будет автоматически заменено __Version__ , которую вы определили ранее.

[NOTE]
====
Если вы видите незнакомый макрос, вы можете узнать о нём с помощью:

[source,bash]
----
$ rpm --eval %{_MACRO}

----

Например:

[source,bash]
----
$ rpm --eval %{_bindir}
/usr/bin

$ rpm --eval %{_libexecdir}
/usr/libexec

----

====

Распространенным макросом является ``%{?dist}``, который обозначает “тег распространения”. Он сигнализирует, какой дистрибутив используется для сборки.

Например:

ifdef::community[]
[source,bash]
----
# On a RHEL 7.x machine
$ rpm --eval %{?dist}
.el7

# On a Fedora 23 machine
$ rpm --eval %{?dist}
.fc23

----
endif::community[]

ifdef::rhel[]
[source,bash]
----
# On a RHEL 7.x machine
$ rpm --eval %{?dist}
.el7

----
endif::rhel[]

Больше информации о макросах см. в разделе xref:more-on-macros[Подробнее о макросах].

[[working-with-spec-files]]
=== Работа со SPEK файлами

Большая часть упаковки программного обеспечения в RPMs - это редактирование файла спецификации. В этом разделе мы обсудим, как создать и изменить файл спецификации.

Чтобы упаковать новое программное обеспечение, вам необходимо создать новый файл спецификации. Вместо того, чтобы писать его вручную с нуля, используйте утилиту ``rpmdev-newspec``. Он создает незаполненный файл спецификации, и Вы заполняете необходимые директивы и поля.

В этом руководстве мы используем три примера реализации программы 'Hello
World!' созданной при подготовке xref:preparing-software-for-packaging[программного обеспечения для упаковки]:

*   https://github.com/redhat-developer/rpm-packaging-guide/raw/master/example-code/bello-0.1.tar.gz[bello-0.1.tar.gz]

*   https://github.com/redhat-developer/rpm-packaging-guide/raw/master/example-code/pello-0.1.1.tar.gz[pello-0.1.1.tar.gz]

*   https://github.com/redhat-developer/rpm-packaging-guide/raw/master/example-code/cello-1.0.tar.gz[cello-1.0.tar.gz]

**   https://raw.githubusercontent.com/redhat-developer/rpm-packaging-guide/master/example-code/cello-output-first-patch.patch[cello-output-first-patch.patch]

Переместите их в ``~/rpmbuild/SOURCES``.

Создайте SPEC файл для каждой из трёх программ:

NOTE: Некоторые текстовые редакторы, ориентированные на программистов, предварительно заполняют новый ``.spec`` файл с их собственным шаблоном спецификации. ``rpmdev-newspec`` предоставляет независимый от редактора метод, именно поэтому он используется в этом руководстве..

[source,bash]
----
$ cd ~/rpmbuild/SPECS

$ rpmdev-newspec bello
bello.spec created; type minimal, rpm version >= 4.11.

$ rpmdev-newspec cello
cello.spec created; type minimal, rpm version >= 4.11.

$ rpmdev-newspec pello
pello.spec created; type minimal, rpm version >= 4.11.

----

``~/rpmbuild/SPECS/`` каталог теперь имеет три SPEC файла с именами
``bello.spec``, ``cello.spec``, и ``pello.spec``.

Изучите файлы. Директивы в них представляют собой директивы, описанные в разделе
xref:what-is-a-spec-file[Что такое SPEK файл].  В следующих разделах вы заполните эти файлы спецификаций.

ifdef::community[]
[NOTE]
====
Утилита ``rpmdev-newspec`` не использует рекомендации или соглашения, характерные для какого-либо конкретного дистрибутива Linux. Однако этот документ предназначен для Fedora, CentOS и RHEL, поэтому вы заметите, что:

* Используйте ``rm $RPM_BUILD_ROOT`` при сборке на  _CentOS_ (версии, предшествующие версии 7.0)
или на https://getfedora.org/[Fedora] (версии, предшествующие версии 18).

* Мы предпочитаем использовать обозначение ``%{buildroot}`` вместо ``$RPM_BUILD_ROOT`` при обращении к Buildroot RPM для обеспечения согласованности со всеми другими определенными или предоставленными макросами во всем файле спецификации..

====
endif::community[]

ifdef::rhel[]
[NOTE]
====
Утилита ``rpmdev-newspec`` не использует рекомендации или соглашения, характерные
для какого-либо конкретного дистрибутива Linux. Однако этот документ ориентирован на RHEL, поэтому
вы заметите, что мы предпочитаем использовать нотацию ``%{buildroot}``, а не
``$RPM_BUILD_ROOT`` при ссылке на Buildroot RPM для обеспечения согласованности со всеми другими определенными или предоставленными макросами во всем файле спецификации.

====
endif::rhel[]

Ниже приведены три примера. Каждый из них полностью описан, так что вы можете перейти к конкретному, если он соответствует вашим потребностям в упаковке. Или прочтите их все, чтобы полностью изучить упаковку различных видов программного обеспечения.

[cols="15%,85%"]
|====
| Имя программы | Объяснение примера
| bello         | Программа, написанная на необработанном интерпретируемом языке программирования. Пример демонстрирует, когда исходный код не нужно создавать, а нужно только установить. Если необходимо упаковать предварительно скомпилированный двоичный файл, вы также можете использовать этот метод, поскольку двоичный файл также будет просто файлом.
| pello         | Программа, написанная на интерпретируемом языке программирования с байтовой компиляцией. Пример демонстрирует байтовую компиляцию исходного кода и установку байт-кода - результирующих, предварительно оптимизированных файлов.
| cello         | Программа, написанная на изначально скомпилированном языке программирования. Пример демонстрирует общий процесс компиляции исходного кода в машинный код и установки результирующих исполняемых файлов.
|====

[[bello-working-with-spec-files]]
==== bello

Первый SPEK файл предназначен для программы ``bello`` bash shell script from
xref:preparing-software-for-packaging[Подготовка программного обеспечения для упаковки].

Убедитесь, что у вас есть:

. Переместите исходный код ``bello`` в ``~/rpmbuild/SOURCES/``.  См. 
xref:working-with-spec-files[Работа со SPEC файлом].

. Теперь создайте пустой SPEC файл``~/rpmbuild/SPECS/bello.spec``. Файл будет иметь следующее содержание:
+
[source,specfile]
----
Name:           bello
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Теперь измените ``~/rpmbuild/SPECS/bello.spec`` для создания RPMs пакета  ``bello``:

. Заполните поля``Name``, ``Version``, ``Release``, и ``Summary`` :
+
* Поле ``Name`` уже было указано в качестве аргумента для  ``rpmdev-newspec``.
+
* Установите  ``Version`` в соответствии с “upstream” версией исходного кода ``bello``, ``0.1``.
+
*  ``Release`` автоматически установит ``1%{?dist}``, что изначально равно 
``1``. Увеличивайте это значение при каждом обновлении пакета без изменения вышестоящей версии ``Version`` - например, при добавлениии патча.
Сбросьте ``Release`` до ``1`` когда произойдёт новый выпуск новой версии программы. Например, если будет выпущена bello версии ``0.2``. Макрос _disttag_ более подробно описан в части про
xref:rpm-macros[].
+
* ``Summary`` - это краткое, однострочное объяснение того, что представляет собой это программное обеспечение.
+
После Ваших изменений первый раздел SPEC файла примет следующий вид:
+
[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

----
+
. Заполните поля ``License``, ``URL``, и ``Source0``:
+
* Поле ``License`` это
ifdef::community[https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение]]
ifdef::rhel[Лицензия на программное обеспечение]
связанная с исходным кодом из upstream-выпуска.
+
ifdef::community[]
Для корректного заполнения поля ``License``, обратитесь к:
https://fedoraproject.org/wiki/Licensing:Main[Fedora Руководство по лицензированию]

endif::community[]
+
Например, используйте ``GPLv3+``.
+
* Поле URL - это URL-адрес страницы upstream-программного обеспечения. для примера, используем 
``https://example.com/bello``. В данном поле рекомендуется использовать макрос %{name}, тогда адрес примет следующий вид: ``https://example.com/%{name}``.
+
* Поле ``Source0`` fсодержит URL-адрес  upstream-исходного кода программного обеспечения. Он должен быть напрямую связан с версией программного обеспечения, которое упаковывается. В этом примере мы можем использовать ``https://example.com/bello/releases/bello-0.1.tar.gz``.
Используйте макросы %{name} и %{version} для учета изменений в версии. В результате адрес примет вид:
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``.
+
После Ваших изменений первая секция SPEC файла примет вид:
+
[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

----
+

. Заполните директивы ``BuildRequires`` и ``Requires`` и подключите директиву ``BuildArch``:
+
*
 ``BuildRequires``  определяет зависимости для пакета во время сборки. Для ``bello`` нет этапа сборки, потому что bash - это необработанный интерпретируемый язык программирования, и файлы просто устанавливаются в их расположение в системе. Просто удалите эту директиву. 
+
* ``Requires`` задает зависимости для пакета во время выполнения, то-есть, необходимые пакеты для работы программы.   Для выполнения скрипта ``bello``
требуется только оболочка  ``bash``, поэтому укажите bash в этой директиве.
+
* Поскольку это программное обеспечение, написанное на интерпретируемом языке программирования без изначально скомпилированных расширений, добавьте директиву ``BuildArch`` со значением``noarch``. Это говорит RPM о том, что этот пакет не нужно привязывать к архитектуре процессора, на которой он построен.
+
После Ваших изменений первая секция SPEC файла примет вид:
+
[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

Requires:       bash

BuildArch:      noarch

----
. Заполните поля ``%description``, ``%prep``, ``%build``, ``%install``,
``%files``, and ``%license``. Эти директивы являются заголовками секций, поскольку они определяют многостроковые, скриптовые или состоящие из нескольких инструкций задачи.
* ``%description`` это более длинное и полное описание программного обеспечения, чем ``Summary``, содержащее один или несколько абзацев. В нашем примере мы будем использовать только краткое описание.
+
* В разделе ``%prep`` Обычно это включает в себя расширение сжатых архивов исходного кода, применение исправлений и, возможно, анализ информации, предоставленной в исходном коде, для использования в следующей части SPEC файла. В этом разделе мы просто используем встроенный макрос ``%setup -q``.
+
* Секция ``%build`` определяет, как на самом деле создавать программное обеспечение, которое мы упаковываем. Однако, поскольку ``bash`` не нужно создавать, просто удалите то, что было предоставлено шаблоном, и оставьте этот раздел пустым.
+
* Секция ``%install`` содержит инструкции для ``rpmbuild``  о том, как установить программное обеспечение после его сборки в каталог ``BUILDROOT``.
Этот каталог представляет собой пустой базовый каталог
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
,который напоминает корневой каталог конечного пользователя. Здесь мы должны создать любые каталоги, которые будут содержать установленные файлы.
+
Поскольку для установки ``bello`` нам нужно только создать каталог назначения и установить туда исполняемый файл ``bash`` скрипт мы будем использовать команду  ``install``. Макросы RPM позволяют нам делать это без жесткого кодирования путей.
+
Секция ``%install`` после ваших изменений должен выглядеть следующим образом:
+
[source,specfile]
----
%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

----
+
* В секци ``%files`` указывается список файлов, предоставляемых этим RPM, и их полный путь в системе конечного пользователя. Следовательно, путь устанавливаемого файла ``bello`` - это ``/usr/bin/bello``, или, с помощью макросов RPM, 
``%{_bindir}/%{name}``.
+
В этом разделе вы можете указать роль различных файлов с помощью встроенных макросов. Это полезно для запроса метаданных манифеста файла пакета с помощью команд
``rpm``. Например, чтобы указать, что файл  LICENSE является файлом лицензии на программное обеспечение, мы используем макрос %license.
+
После изменения, секция``%files`` примет следующий вид:
+
[source,specfile]
----
%files
%license LICENSE
%{_bindir}/%{name}

----
+
. Последняя секция, ``%changelog``, представляет собой список записей с отметкой даты для каждой версии-выпуска пакета. Они регистрируют изменения упаковки, а не изменения программного обеспечения. Примеры изменений упаковки: добавление исправления, изменение процедуры сборки в ``%build``.
+
Следуйте следующему формату для первой строки:
+
`* Day-of-Week Month Day Year Name Surname <email> - Version-Release`
+
Следуйте данным правилам для фактической записи изменений:
+
--
* Каждая запись об изменении может содержать несколько элементов - по одному для каждого изменения
* Каждый элемент начинается с новой строки.
* Каждый элемент начинается с символа ``-``. .
--
+
Пример записи с отметкой даты
+
[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First bello package
- Example second item in the changelog for version-release 0.1-1

----

Вы написали целый файл спецификации **bello**. Послный SPEC файл **bello** теперь выглядит так:

[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Requires:       bash

BuildArch:      noarch

%description
The long-tail description for our Hello World Example implemented in
bash script.

%prep
%setup -q

%build

%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

%files
%license LICENSE
%{_bindir}/%{name}

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First bello package
- Example second item in the changelog for version-release 0.1-1

----

В следующем разделе рассказывается о том, как создать RPM.

[[pello-working-with-spec-files]]
==== pello

Наш второй SPEC будет для примера, написанного на языке программирования the https://www.python.org/[Python]
который вы скачали (или вы создали имитированный upstream- выпуск в разделе xref:preparing-software-for-packaging[Подготовка программного обеспечения]) и разместили его исходный код в ``~/rpmbuild/SOURCES/``. Давайте продолжим и откроем файл  ``~/rpmbuild/SPECS/pello.spec``  начнем заполнять некоторые поля.

Прежде чем мы начнем идти по этому пути, нам нужно рассмотреть кое-что несколько уникальное в интерпретируемом программном обеспечении с байт-компиляцией. Поскольку использовать байт-компиляцию,
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
больше не применим, поскольку результирующий файл не будет содержать запись. Обычной практикой является либо наличие небайтового скомпилированного сценария оболочки, который будет вызывать исполняемый файл, либо наличие небольшого фрагмента кода 
https://www.python.org/[Python] , который не скомпилирован в байтах, в качестве “точки входа” в выполнение программы. Это может показаться глупым для нашего небольшого примера, но для больших программных проектов со многими тысячами строк кода увеличение производительности при предварительной байт-компиляции кода является значительным.

NOTE: Создание скрипта для вызова байт-скомпилированного кода или наличие небайт-скомпилированной точки входа в программное обеспечение - это то, к чему разработчики upstream программного обеспечения чаще всего обращаются перед выпуском своего программного обеспечения в мир, однако это не всегда так, и это упражнение призвано помочь решить, что делать в таких ситуациях. Для получения дополнительной информации о том, как обычно выпускается и распространяется код
https://www.python.org/[Python], пожалуйста, обратитесь к следующей документации: https://docs.python.org/2/library/distribution.html[Упаковка и распространение программного обеспечения].

Мы создадим небольшой сценарий оболочки для вызова нашего байт-скомпилированного кода, который станет точкой входа в наше программное обеспечение. Мы сделаем это как часть самого нашего файла спецификации, чтобы продемонстрировать, как вы можете создавать сценарии действий внутри SPEC файла. Мы рассмотрим эти особенности позже в разделе ``%install``.

Давайте продолжим и откроем файл  ``~/rpmbuild/SPECS/pello.spec``  и начнем заполнять некоторые поля.

Ниже приведен шаблон вывода, который мы получили из``rpmdev-newspec``.

[source,specfile]
----
Name:           pello
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Как и в первом примере, давайте начнем с первого набора директив, которые ``rpmdev-newspec``сгруппировал в верхней части файла: ``Name``,
``Version``, ``Release``, ``Summary``. Поле ``Name`` уже заполнено, так как мы передали его в командной строке при использовании команды ``rpmdev-newspec``.

Давайте установим  ``Version`` соответствующую версии “upstream” релиза исходного кода
__pello__ , которая, как мы видим, равна ``0.1.1``, как указано в примире кода, который мы загрузили (или создали в разделе
xref:preparing-software-for-packaging[Подготовка программного обеспечения] section).

В поле ``Release`` уже установлено значение ``1%{?dist}`` которое изначально равно ``1``, и должно увеличиваться каждый раз, когда пакет обнавляется по какой-либо причине, например, включает новый патч для устранения проблемы, но не имеет новой версии upstream-выпуска. Когда происходит новый upstream-выпуск (например, была выпущена версия pello ``0.1.2``) тогда ``Release`` должен быть сброшен до значения ``1``. _disttag_``%{?dist}`` выглядит знакоммо по описанию макросов из xref:rpm-macros[] в предыдущем разделе.

 ``Summary`` должно представлять собой краткое, в одну строку, объяснение того, что представляет собой это программное обеспечение.

После Ваших изменений первый раздел SPEC файла примет следующий вид:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

----

Теперь давайте перейдем ко второму набору директив, которые ``rpmdev-newspec`` сгруппировал вместе в нашем SPEC файле: ``License``, ``URL``, ``Source0``.

ifdef::community[]
Поле ``License`` это 
https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение] связанная с исходным кодом из upstream выпуска.  Точный формат обозначения лицензии в вашем файле  SPEC будет варьироваться в зависимости от того, каким конкретным рекомендациям по дистрибутиву
https://en.wikipedia.org/wiki/Linux[Linux], использующим RPM, вы следуете. Мы будем использовать стандарты обозначения из
https://fedoraproject.org/wiki/Licensing:Main[Fedora Руководство по лицензированию], поэтому это поле будет содержать лицензию ``GPLv3+``
endif::community[]

ifdef::rhel[]
Поле ``License`` это 
https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение] связанная с исходным кодом из upstream выпуска.  Точный формат обозначения лицензии в вашем файле  SPEC будет варьироваться в зависимости от того, каким конкретным рекомендациям по дистрибутиву
https://en.wikipedia.org/wiki/Linux[Linux], использующим RPM, вы следуете.
endif::rhel[]


Поле ``URL`` - это веб-сайт upstream программного обеспечения. Это не ссылка на скачивание исходного кода, а фактический веб-сайт проекта, продукта или компании, где кто-то может найти больше информации об этой конкретной части программного обеспечения. Поскольку это просто пример, мы будем использовать адрес. ``https://example.com/pello``. Однако, мы применим макрос RPM  ``%{name}`` для корректности оформления.

Поле ``Source0`` это место, откуда должен быть загружен upstrem исходный код программного обеспечения. Этот URL-адрес должен содержать прямую ссылку на конкретную версию выпуска исходного кода, которую мы упаковываем. Еще раз, поскольку это пример, мы будем использовать ссылку на следующий архив:
``https://example.com/pello/releases/pello-0.1.1.tar.gz``

Мы должны отметить, что в этом примере URL-адреса есть жестко закодированные значения, которые можно изменить в будущем и потенциально они даже могут измениться, например, версия выпуска ``0.1.1``. Мы можем упростить это, если потребуется обновить только одно поле в SPEC файле и разрешить его повторное использование. 
Мы будем использовать макросы
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``, вместо ссылок из примеров раннее.

После ваших изменений верхняя часть вашего SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

----

У нас есть секции ``BuildRequires`` и ``Requires``, каждый из которых определяет что-то, что требуется для пакета. Однако , ``BuildRequires`` должен сообщать
``rpmbuild`` о том, что необходимо вашему пакету во время **сборки**, а``Requires`` - это то, что необходимо вашему пакету во время **установки**.

В этом примере нам понадобится пакет ``python`` для выполнения процесса сборки с байт-компиляцией.  Этот пакет понадобится во время выполнения байт-скомпилированного кода, поэтому нам необходимо определить ``python`` как требуемый пакет в директиве ``Requires``. Нам также понадобится пакет ``bash`` для выполнения небольшого сценария точки входа, который мы будем использовать здесь.

 Поскольку эта программа написана на интерпритируемом языке программирования без изначально скомпилированных расширений, нужно добавить секцию ``BuildArch``. В ней задано значение noarch, чтобы сообщить RPM, что этот пакет не нужно привязывать к архитектуре процессора, на которой он построен.

После ваших изменений верхняя часть вашего SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch

----

Следующие директивы можно рассматривать как “заголовки разделов”, поскольку они являются директивами, которые могут определять многостроковые, скриптовые или состоящие из нескольких инструкций задачи. Мы пройдемся по ним один за другим, как и по предыдущим пунктам.

Секция %description - это более длинное и полное описание программного обеспечения, чем ``Summary``, содержащее один или несколько абзацев. В нашем примере мы будем использовать только краткое описание. В нашем примере это секция не будет содержать глубокое описание, но при желании этот раздел может быть целым абзацем или более.

Секция ``%prep`` это место, где мы __подготавливаем__ нашу среду сборки или рабочее пространство для сборки. Чаще всего здесь происходит расширение сжатых архивов исходного кода, применение исправлений и, возможно, анализ информации, предоставленной в исходном коде, которая необходима в следующей части  SPEC файла. IВ этом разделе мы просто будем использовать предоставленный макрос ``%setup -q``.

Секция ``%build``- это раздел, где мы рассказываем системе, как на самом деле создавать программное обеспечение, которое мы упаковываем. Здесь мы выполним байтовую компиляцию нашего программного обеспечения. Для тех, кто читал раздел xref:preparing-software-for-packaging[Подготовка программного обеспечения], эта часть примера должна показаться знакомой.

Секчия ``%build`` нашего SPEC файла должна выглядеть следующим образом.

[source,specfile]
----
%build

python -m compileall pello.py

----

Секция ``%install`` это раздел, отвечающий за инструктирование ``rpmbuild``, как установить наше ранее созданное программное обеспечение в ``BUILDROOT`` который фактически является базовым каталогом
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
в котором ничего нет, и нам нужно будет создать любые пути или иерархии каталогов, которые нам понадобятся, чтобы установить наше программное обеспечение здесь в их определенных местах. Однако наши макросы RPM помогают нам выполнить эту задачу без необходимости жестко кодировать пути.

Ранее мы обсуждали, что, поскольку мы потеряем контекст файла со строкой
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
в нем при байт-компиляции, нам нужно будет создать простой сценарий-оболочку для выполнения этой задачи.  Есть много вариантов того, как это сделать, включая, но не ограничиваясь этим, создание отдельного скрипта и использование его в качестве отдельной директивы ``SourceX``, а также вариант, который мы собираемся показать в этом примере, который заключается в создании файла в строке в SPEC файле. Причина, по которой мы показываем примерный вариант, заключается в том, чтобы просто продемонстрировать, что сам файл спецификации доступен для сценариев. Что мы собираемся сделать, так это создать небольшой “сценарий-оболочку”, который будет выполнять байт-скомпилированный код
https://www.python.org/[Python] используя
ifdef::community[https://en.wikipedia.org/wiki/Here_document[here document]]
ifdef::rhel["here" document]
. Нам также нужно будет фактически установить 
байт-скомпилированный файл в каталог библиотеки в системе, чтобы к нему можно было получить доступ.

NOTE: Ниже вы заметите, что мы жестко кодируем путь к библиотеке. Существуют различные методы, позволяющие избежать необходимости делать это, многие из которых рассматриваются в
<<дополнительных разделах>>, в разделе xref:more-on-macros[Подрбнее о макросах], и специфичны для языка программирования, на котором было написано упаковываемое программное обеспечение. В этом примере мы жестко закодировали путь для простоты, чтобы не охватывать слишком много тем одновременно.

Секция ``%install`` после Ваших изменений должна выглядеть следующим образом:

[source,specfile]
----
%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat > %{buildroot}/%{_bindir}/%{name} <<-EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

----

Секция ``%files`` это место, где мы предоставляем список файлов, которые предоставляет этот RPM, и где они должны находиться в системе, на которую установлен RPM. Обратите внимание, что это относится не к ``%{buildroot}`` а к полному пути к файлам, поскольку ожидается, что они будут существовать в конечной системе после установки. Таким образом, список устанавливаемого файла ``pello``  будет ``%{_bindir}/pello``.  Нам также нужно будет предоставить список ``%dir``, чтобы определить, что этот пакет “владеет” каталогом библиотеки, который мы создали, а также всеми файлами, которые мы разместили в нем.

Кроме того, в этом разделе вам иногда понадобится встроенный макрос для предоставления контекста для файла. Это может быть полезно для системных администраторов и конечных пользователей, которые могут захотеть запросить систему с помощью ``rpm`` о конечном пакете. Встроенный макрос, который мы будем использовать здесь, - это ``%license``, который сообщит ``rpmbuild``, что это файл лицензии на программное обеспечение в метаданных манифеста файла пакета.

Секция ``%files`` после Ваших изменений должен выглядеть следующим образом:
[source,specfile]
----
%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*

----

Последняя секция, ``%changelog``, представляет собой список записей с отметками о дате, которые соотносятся с конкретной версией-выпуском пакета. Это не журнал изменений в программном обеспечении от выпуска к выпуску, а конкретно изменения в упаковке. Например, если программное обеспечение в пакете нуждалось в исправлении или было необходимо внести изменения в процедуру сборки, указанную в секции``%build``, эта информация будет размещена здесь. Каждая запись изменения может содержать несколько элементов, и каждый элемент должен начинаться с новой строки и начинаться с символа ``-``.
Ниже приведен наш пример записи:

[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1.1-1
- First pello package
- Example second item in the changelog for version-release 0.1.1-1

----

Обратите внимание на приведенный выше формат, отметка даты будет начинаться с символа ``*``, за которым следует календарный день недели, месяц, день месяца, год, затем контактная информация для упаковщика RPM. Оттуда у нас есть символ``-`` перед выпуском версии, что является часто используемым, но не строго регламентированным. Затем, наконец, Версия-Релиз.

Вот и все! Мы написали целый файл спецификаций для **pello**! В следующем разделе мы расскажем, как создать RPM!

Полный файл спецификации теперь должен выглядеть следующим образом:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in python

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch

%description
The long-tail description for our Hello World Example implemented in
Python.

%prep
%setup -q

%build

python -m compileall %{name}.py

%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat > %{buildroot}/%{_bindir}/%{name} <<-EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1.1-1
  - First pello package

----

[[cello-working-with-spec-files]]
==== cello

Наш третий SPEC файл будет для нашего примера на языке
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
, для которого мы ранее создали имитированную версию upstream (или вы скачали) и разместили его исходный код в ``~/rpmbuild/SOURCES/`` ранее.

Давайте откроем файл ``~/rpmbuild/SPECS/cello.spec`` и начнём заполнять некоторые поля. 

Ниже приведен шаблон вывода, который мы получили от  ``rpmdev-newspec``.

[source,specfile]
----
Name:           cello
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----
Как и в предыдущих примерах, давайте начнем с первого набора директив, которые ``rpmdev-newspec`` сгруппировал в верхней части файла: 
``Name``, ``Version``, ``Release``, ``Summary``. The ``Name`` уже указано, потому что мы предоставили эту информацию в командной строке для ``rpmdev-newspec``.

Давайте установим в поле ``Version`` значение, соответствующее “upstream” версии исходного кода
__cello__, которая, как мы видим, равна ``1.0``, как указано в примере кода, который мы загрузили (или создали в секции xref:preparing-software-for-packaging[Подготовка программного обеспечения]).

В ``Release`` уже установлено значение ``1%{?dist}``  числовое значение, которое изначально равно ``1``, должно увеличиваться каждый раз, когда пакет обновляется по какой-либо причине, например, включает новый патч для устранения проблемы, но не имеет новой версии upstream выпуска. Когда происходит новый upstream выпуск  (например, была выпущена версия cello ``2.0``), тогда значение ``Release`` должно быть сброшено до``1``.  _disttag_``%{?dist}`` выглядит знакоммо по описанию макросов из xref:rpm-macros[] в предыдущем разделе.

``Summary`` должно представлять собой краткое, в одну строку, объяснение того, что представляет собой это программное обеспечение.

После ваших изменений первый раздел SPEC файла должен выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C
----

Теперь давайте перейдем ко второму набору директив, которые ``rpmdev-newspec`` сгруппировал вместе в нашем SPEC файле: ``License``, ``URL``, ``Source0``. Однако, мы добавим одну директиву в эту группу, поскольку она тесно связана с ``Source0`` , и это наш  ``Patch0`` в котором будет указан первый патч, который нам нужен для нашего программного обеспечения.


Поле ``License`` это 
https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение] связанная с исходным кодом из upstream выпуска.  Точный формат обозначения лицензии в вашем файле  SPEC будет варьироваться в зависимости от того, каким конкретным рекомендациям по дистрибутиву
https://en.wikipedia.org/wiki/Linux[Linux], использующим RPM, вы следуете. Мы будем использовать стандарты обозначения из
https://fedoraproject.org/wiki/Licensing:Main[Fedora Руководство по лицензированию], поэтому это поле будет содержать лицензию ``GPLv3+``

Поле ``URL`` - это веб-сайт upstream программного обеспечения. Это не ссылка на скачивание исходного кода, а фактический веб-сайт проекта, продукта или компании, где кто-то может найти больше информации об этой конкретной части программного обеспечения. Поскольку это просто пример, мы будем использовать адрес. ``https://example.com/сello``. Однако, мы применим макрос RPM  ``%{name}`` для корректности оформления.

Поле ``Source0`` это место, откуда должен быть загружен upstrem исходный код программного обеспечения. Этот URL-адрес должен содержать прямую ссылку на конкретную версию выпуска исходного кода, которую мы упаковываем. Еще раз, поскольку это пример, мы будем использовать ссылку на следующий архив:
``https://example.com/cello/releases/cello-1.0.tar.gz``

Мы должны отметить, что в этом примере URL-адреса есть жестко закодированные значения, которые можно изменить в будущем и потенциально они даже могут измениться, например, версия выпуска ``1.0``. Мы можем упростить это, если потребуется обновить только одно поле в SPEC файле и разрешить его повторное использование. 
Мы будем использовать макросы
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``, вместо ссылок из примеров раннее.

Следующий пункт - предоставить список для файла ``.patch`` который мы создали ранее, чтобы мы могли применить его к коду позже в секции``%prep``. Нам понадобится список  ``Patch0: cello-output-first-patch.patch``.

После ваших изменений верхняя часть вашего SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

Patch0:         cello-output-first-patch.patch

----

У нас есть секции ``BuildRequires`` и ``Requires``, каждый из которых определяет что-то, что требуется для пакета. Однако , ``BuildRequires`` должен сообщать
``rpmbuild`` о том, что необходимо вашему пакету во время **сборки**, а``Requires`` - это то, что необходимо вашему пакету во время **установки**.

В этом примере нам понадобятся пакеты ``gcc`` и ``make`` для выполнения процесса сборки компиляции. Требования времени выполнения, к счастью, обрабатываются для нас `rpmbuild` потому что эта программа не требует ничего за пределами основных стандартных библиотек
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
, и поэтому нам не нужно будет определять что-либо вручную в качестве ``Requires`` , и мы можем опустить эту директиву.

После Ваших изменений верхняя часть SPEC Вашего файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

BuildRequires:  gcc
BuildRequires:  make

----

Следующие директивы являются заголовками секций, поскольку они определяют многостроковые, скриптовые или состоящие из нескольких инструкций задачи. Мы пройдемся по ним один за другим, как и по предыдущим пунктам.

Секция ``%description`` это более длинное и полное описание программного обеспечения, чем ``Summary``, содержащее один или несколько абзацев. В нашем примере мы будем использовать только краткое описание. В нашем примере это секция не будет содержать глубокое описание, но при желании этот раздел может быть целым абзацем или более.

Секция ``%prep`` это место, где мы __подготавливаем__ нашу среду сборки или рабочее пространство для сборки. Чаще всего здесь происходит расширение сжатых архивов исходного кода, применение исправлений и, возможно, анализ информации, предоставленной в исходном коде, которая необходима в следующей части  SPEC файла. IВ этом разделе мы просто будем использовать предоставленный макрос ``%setup -q``.

Секция ``%build`` это то, где мы рассказываем системе, как на самом деле создавать программное обеспечение, которое мы упаковываем. Поскольку мы написали простой  ``Makefile`` для нашей реализации на
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
, мы можем просто использовать команду http://www.gnu.org/software/make/[GNU make], предоставленную
``rpmdev-newspec``. Однако нам нужно удалить вызов, ``%configure``, поскольку мы не предоставили
ifdef::community[https://en.wikipedia.org/wiki/Configure_script[configure script]]
ifdef::rhel[configure script]
. Секция ``%build`` нашего SPEC должен выглядеть следующим образом. 

[source,specfile]
----
%build
make %{?_smp_mflags}

----

Секция ``%install``  это то, где мы инструктируем ``rpmbuild`` как установить наше ранее созданное программное обеспечение в ``BUILDROOT`` wкоторый фактически является базовым каталогом
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
в котором ничего нет, и нам нужно будет создать любые пути или иерархии каталогов, которые нам понадобятся, чтобы установить наше программное обеспечение здесь в их определенных местах. Однако наши макросы RPM помогают нам выполнить эту задачу без необходимости жестко кодировать пути.

Еще раз, поскольку у нас есть простой  ``Makefile`` , шаг установки можно легко выполнить, оставив на месте макрос ``%make_install`` , который снова был предоставлен нам командой ``rpmdev-newspec``.

Секция ``%install`` после Ваших изменений должна принять следующий вид:

[source,specfile]
----
%install
%make_install

----

Секция ``%files``  это место, где мы предоставляем список файлов, которые предоставляет этот RPM, и где они должны находиться в системе, на которую установлен RPM. Обратите внимание, что это относится не к ``%{buildroot}``, а к полному пути к файлам, поскольку ожидается, что они будут существовать в конечной системе после установки. Таким образом путь устанавливаемого файла ``cello`` будет ``%{_bindir}/cello``.

Кроме того, в этом разделе вам иногда понадобится встроенный макрос для предоставления контекста для файла. Это может быть полезно для системных администраторов и конечных пользователей, которые могут захотеть запросить систему с помощью ``rpm`` о конечном пакете. Встроенный макрос, который мы будем использовать здесь, - это ``%license``, который сообщит ``rpmbuild``, что это файл лицензии на программное обеспечение в метаданных манифеста файла пакета.

Секция ``%files`` после Ваших изменений должна выглядеть следующим образом:

[source,specfile]
----
%files
%license LICENSE
%{_bindir}/%{name}

----

Последняя секция, ``%changelog``, представляет собой список записей с отметками о дате, которые соотносятся с конкретной версией-выпуском пакета. Это не журнал изменений в программном обеспечении от выпуска к выпуску, а конкретно изменения в упаковке. Например, если программное обеспечение в пакете нуждалось в исправлении или было необходимо внести изменения в процедуру сборки, указанную в секции``%build``, эта информация будет размещена здесь. Каждая запись изменения может содержать несколько элементов, и каждый элемент должен начинаться с новой строки и начинаться с символа ``-``.
Ниже приведен наш пример записи:

[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First cello package

----

Обратите внимание на приведенный выше формат, отметка даты будет начинаться с символа ``*``, за которым следует календарный день недели, месяц, день месяца, год, затем контактная информация для упаковщика RPM. Оттуда у нас есть символ``-`` перед выпуском версии, что является часто используемым, но не строго регламентированным. Затем, наконец, Версия-Релиз.

Вот и все! Мы написали целый файл спецификаций для **cello**! В следующем разделе мы расскажем, как создать RPM!

Полный файл спецификации теперь должен выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Patch0:         cello-output-first-patch.patch

BuildRequires:  gcc
BuildRequires:  make

%description
The long-tail description for our Hello World Example implemented in
C.

%prep
%setup -q

%patch0

%build
make %{?_smp_mflags}

%install
%make_install

%files
%license LICENSE
%{_bindir}/%{name}

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 1.0-1
- First cello package

----

Пакет ``rpmdevtools`` предоставляет набор шаблонов файлов спецификаций для нескольких популярных языков в каталоге``/etc/rpmdevtools/``.

[[building-rpms]]
== Создание RPMS

RPMs создаются с помощью команды  ``rpmbuild``. Различные сценарии и желаемые результаты требуют различных комбинаций аргументов для ``rpmbuild``. В этом разделе описываются два основных сценария:

. создание исходного RPM
. создание бинарного RPM

Команда ``rpmbuild`` ожидает определенную структуру каталогов и файлов.  Это та же структура, что и в утилите ``rpmdev-setuptree``. Предыдущие инструкции также подтвердили требуемую структуру.

[[source-rpms]]
=== Исходный RPMs

Зачем создавать исходный RPM (SRPM)?

. Чтобы сохранить точный источник определенного Name-Version-Release RPM, который был развернут в среде.  Это включает в себя точный SPEC файл, исходный код и все соответствующие исправления. Это полезно для просмотра истории и для отладки.
ifdef::community[]
. Чтобы иметь возможность создавать двоичный RPM на другой аппаратной платформе или
https://en.wikipedia.org/wiki/Microarchitecture[архитектуре].
endif::community[]

ifdef::rhel[]
. Чтобы иметь возможность создавать двоичный RPM на другой аппаратной платформе или архитектуре.
endif::rhel[]

[[create-source-rpms]]
==== Для создания SRPM:

[source,bash]
----
$ rpmbuild -bs _SPECFILE_

----

Замените _SPECFILE_ SPEC файлом. Параметр  ``-bs`` "исходный код сборки".

Здесь мы создаем SRPMs для ``bello``, ``pello`` и ``cello``:

[source,bash]
----
$ cd ~/rpmbuild/SPECS/

$ rpmbuild -bs bello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm

$ rpmbuild -bs pello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm

$ rpmbuild -bs cello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm

----

Обратите внимание, что SRPMS были помещены в каталог  ``rpmbuild/SRPMS`` directory, который является частью структуры, ожидаемой ``rpmbuild``.

Это все, что нужно для создания SRPM.

[[binary-rpms]]
=== Бинарный RPMS

Существует два метода построения бинарных RPMs:

. Восстановление его из SRPM с использованием комманды``rpmbuild --rebuild``.
. Строим его из файла спецификации с помощью команды ``rpmbuild -bb``. Опция  ``-bb`` означает "построить двоичный файл" (``build binary``).

[[rebuild]]
==== Восстановление из исходного RPM

Чтобы перестроить ``bello``, ``pello`` и ``cello`` из исходных RPM (SRPMs), запустите:

[source,bash]
----
$ rpmbuild --rebuild ~/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm
[output truncated]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm
[output truncated]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
[output truncated]

----

Теперь вы создали RPM. Несколько заметок:

* Выходные данные, генерируемые при создании бинарного RPM, являются подробными, что полезно для отладки. Выходные данные различаются для разных примеров и соответствуют их SPEC файлам.
*  Конечные бинарные RPM находятся в   ``~/rpmbuild/RPMS/YOURARCH`` где ``YOURARCH`` - это ваша
ifdef::community[https://en.wikipedia.org/wiki/Microarchitecture[архитектура]]
ifdef::rhel[архитектура]
или в
``~/rpmbuild/RPMS/noarch/`` если пакет не зависит от архитектуры.
* Вызов ``rpmbuild --rebuild`` включает в себя:
+
--
. Установка содержимого RPM - файла спецификации и исходного кода - в ``~/rpmbuild/`` directory.
. Построение с использованием установленного содержимого.
. Удаление файла спецификации и исходного кода..
--
+
Вы можете сохранить файл спецификации и исходный код после сборки. Для этого у вас есть два варианта:
+
--
* При сборке используйте опцию  ``--recompile`` вместо ``--rebuild``.
* Установите SRPMS с помощью следующих команд:
--
+
[source,bash]
----
$ rpm -Uvh ~/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm
Updating / installing...
   1:bello-0.1-1.el7                  ################################# [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm
Updating / installing...
   1:pello-0.1.1-1.el7                ################################# [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
Updating / installing...
   1:cello-1.0-1.el7                  ################################# [100%]

----
+
В этом руководстве выполните приведенные выше команды ``rpm -Uvh`` чтобы продолжить взаимодействие с файлами спецификаций и исходными кодами.

[[build-binary]]
==== Создание бинарного файла из SPEC файла

Чтобы создать ``bello``, ``pello``, and ``cello`` из их SPEC файлов, запустите:

[source,bash]
----
$ rpmbuild -bb ~/rpmbuild/SPECS/bello.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/pello.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/cello.spec

----

Теперь вы создали RPM из SPEC файлов.

Большая часть информации, содержащейся в разделе in xref:rebuild[] применима здесь.

[[checking-rpms-for-sanity]]
== Проверка RPMs на корректность

После создания упаковки хорошо бы проверить ее качество. Качество пакета, а не программного обеспечения, поставляемого в нем. Основным инструментом для этого является
https://github.com/rpm-software-management/rpmlint[rpmlint]. Это улучшает редактируемость RPM и обеспечивает проверку работоспособности и ошибок путем выполнения статического анализа  RPM. Эта утилита может проверять двоичные RPM, исходные RPM (SRPMs) и spec файлы, поэтому она полезна на всех этапах упаковки, как показано в следующих примерах.

Обратите внимание, что ``rpmlint`` имеет очень строгие правила, и иногда допустимо и необходимо пропустить некоторые из его ошибок и предупреждений, как показано в следующих примерах.
examples.

NOTE: В примерах мы запускаем ``rpmlint`` без каких-либо опций, что приводит к невербальному выводу. Для получения подробных объяснений каждой ошибки или предупреждения вместо этого запустите 
``rpmlint -i`` instead.

[[checking-bello-spec-file]]
=== Проверка SPEC файла bello

Это результат выполнения  ``rpmlint`` в SPEC файле ``bello``:

[source,bash]
----
$ rpmlint bello.spec
bello.spec: W: invalid-url Source0: https://www.example.com/bello/releases/bello-0.1.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.

----

Наблюдения:

* Для ``bello.spec`` есть только одно предупреждение. В нем говорится, что URL-адрес, указанный в директиве
``Source0`` недоступен. Это ожидаемо, поскольку указанный ``example.com`` URL-адрес не существует. Предполагая, что мы ожидаем, что этот URL-адрес будет работать в будущем, мы можем проигнорировать это предупреждение

Это результат выполнения ``rpmlint`` на SRPM для ``bello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm
bello.src: W: invalid-url URL: https://www.example.com/bello HTTP Error 404: Not Found
bello.src: W: invalid-url Source0: https://www.example.com/bello/releases/bello-0.1.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.

----

Наблюдения:

* Для ``bello`` SRPM появилось новое предупреждение, в котором говорится, что URL-адрес, указанный в директиве URL, недоступен. Предполагая, что ссылка будет работать в будущем, мы можем проигнорировать это предупреждение..

[[checking-bello-binary-rpm]]
=== Проверка бинарного RPM bello

При проверке бинарных RPMs, ``rpmlint`` проверяет дополнительные параметры, в том числе:

. документацию
ifdef::community[. https://en.wikipedia.org/wiki/Man_page[страницы руководства]]
ifdef::rhel[. страницы руководства]
ifdef::community[. корректность  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии файловой системы]]
ifdef::rhel[. корректность Иерархии Файловой Системы]

Это результат выполнения``rpmlint`` на бинарном RPM для ``bello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/noarch/bello-0.1-1.el7.noarch.rpm
bello.noarch: W: invalid-url URL: https://www.example.com/bello HTTP Error 404: Not Found
bello.noarch: W: no-documentation
bello.noarch: W: no-manual-page-for-binary bello
1 packages and 0 specfiles checked; 0 errors, 3 warnings.

----

Наблюдения:

* ``no-documentation`` и``no-manual-page-for-binary`` оворят о том, что в RPM нет документации или страниц руководства, потому что мы их не предоставили.
Apart from the above warnings, our RPM is passing ``rpmlint`` checks.

[[checking-pello-spec-file]]
=== Проверка SPEC файла pello 

Это результат выполнения ``rpmlint`` в файле спецификации для ``pello``:

[source,bash]
----
$ rpmlint pello.spec
pello.spec:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pello.spec:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pello.spec:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pello.spec:43: E: hardcoded-library-path in /usr/lib/%{name}/
pello.spec:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pello.spec: W: invalid-url Source0: https://www.example.com/pello/releases/pello-0.1.1.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 5 errors, 1 warnings.

----

Наблюдения:

* Предупреждение ``invalid-url Source0`` wговорит о том, что URL-адрес, указанный в директиве Source0 - недоступен. Это ожидаемо, поскольку указанный example.com URL-адрес не существует. Предполагая, что мы ожидаем, что этот URL-адрес будет работать в будущем, мы можем проигнорировать это предупреждение.
* Ошибок много, потому что мы намеренно написали этот файл спецификации, чтобы он был простым и показывал, о каких ошибках может сообщать ``rpmlint``.
* Ошибки ``hardcoded-library-path`` предполагают использование макроса  ``%{_libdir}`` вместо жесткого кодирования пути к библиотеке. Ради этого примера мы игнорируем эти ошибки, но для пакетов, запущенных в производство, вам нужна веская причина для игнорирования этой ошибки.

Это результат выполнения ``rpmlint`` на SRPM для ``pello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm
pello.src: W: invalid-url URL: https://www.example.com/pello HTTP Error 404: Not Found
pello.src:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pello.src:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pello.src:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pello.src:43: E: hardcoded-library-path in /usr/lib/%{name}/
pello.src:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pello.src: W: invalid-url Source0: https://www.example.com/pello/releases/pello-0.1.1.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 5 errors, 2 warnings.

----

Наблюдения:

* Новая ошибка``invalid-url URL`` здесь связана с директивой ``URL`` которая недоступна.  Предполагая, что мы ожидаем, что URL-адрес станет действительным в будущем, мы можем игнорировать эту ошибку.

[[checking-pello-binary-rpm]]
=== Проверка бинарного RPM pello 

При проверке бинарного RPMs, ``rpmlint`` проверяет дополнительные параметры, в том числе:


. документацию
ifdef::community[. https://en.wikipedia.org/wiki/Man_page[страницы руководства]]
ifdef::rhel[. страницы руководства]
. последовательное использование
ifdef::community[. корректность  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии файловой системы]]
ifdef::rhel[. корректность Иерархии Файловой Системы]

Это результат выполнения ``rpmlint`` на бинарном RPM для ``pello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/noarch/pello-0.1.1-1.el7.noarch.rpm
pello.noarch: W: invalid-url URL: https://www.example.com/pello HTTP Error 404: Not Found
pello.noarch: W: only-non-binary-in-usr-lib
pello.noarch: W: no-documentation
pello.noarch: E: non-executable-script /usr/lib/pello/pello.py 0644L /usr/bin/env
pello.noarch: W: no-manual-page-for-binary pello
1 packages and 0 specfiles checked; 1 errors, 4 warnings.

----

Наблюдения:

* Предупреждения  ``no-documentation`` и ``no-manual-page-for-binary`` говорят о том, что в RPM нет документации или страниц руководства, потому что мы их не предоставили.
* Предупреждение  ``only-non-binary-in-usr-lib`` гласит, что вы предоставили только бинарные артефакты  ``/usr/lib/``. Этот каталог обычно зарезервирован для общих объектных файлов, которые являются бинарными файлами. Следовательно, ``rpmlint`` eожидает, что по крайней мере один или несколько файлов в ``/usr/lib/`` будут бинарными.
+
Это пример проверки ``rpmlint`` на соответствие
ifdef::community[https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии Файловой Системы]]
ifdef::rhel[Иерархии Файловой системы ]
.
+
Обычно для обеспечения правильного размещения файлов используются макросы RPM. Ради этого примера мы можем проигнорировать это предупреждение.
* Ошибка ``non-executable-script`` предупреждает о том, что ``/usr/lib/pello/pello.py``
файл не имеет прав на выполнение. Поскольку этот файл содержит
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
, ``rpmlint`` ожидает, что файл будет исполняемым. Для целей примера оставьте этот файл без разрешений на выполнение и проигнорируйте эту ошибку.


Помимо вышеприведенных предупреждений и ошибок, наш RPM проходит проверку ``rpmlint``.

[[checking-cello-spec-file]]
=== Проверка SPEC файла cello 

Это результат выполнения ``rpmlint`` в SPEC файле ``cello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SPECS/cello.spec
/home/admiller/rpmbuild/SPECS/cello.spec: W: invalid-url Source0: https://www.example.com/cello/releases/cello-1.0.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.

----

Наблюдения:

* Единственное предупреждение для ``cello.spec`` гласит, что URL-адрес, указанный в директиве 
``Source0``, недоступен. Это ожидаемо, поскольку указанный ``example.com`` URL-адрес не существует. Предполагая, что мы ожидаем, что этот URL-адрес будет работать в будущем, мы можем проигнорировать это предупреждение.

Это результат выполнения ``rpmlint`` в файле SRPM для ``cello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
cello.src: W: invalid-url URL: https://www.example.com/cello HTTP Error 404: Not Found
cello.src: W: invalid-url Source0: https://www.example.com/cello/releases/cello-1.0.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.

----

Наблюдения:

* Для ``cello`` SRPM появилось новое предупреждение, в котором говорится, что URL-адрес, указанный в директиве ``URL``, недоступен.  Предполагая, что ссылка будет работать в будущем, мы можем проигнорировать это предупреждение.

[[checking-cello-binary-rpm]]
=== Проверка бинарного RPM cello

При проверке бинарных RPMs, ``rpmlint`` проверяет дополнительные параметры, в том числе:

. документацию
ifdef::community[. https://en.wikipedia.org/wiki/Man_page[страницы руководства]]
ifdef::rhel[. страницы руководства]
ifdef::community[. корректность  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии файловой системы]]
ifdef::rhel[. корректность Иерархии Файловой Системы]
.

Это результат выполнения ``rpmlint`` на бинарном RPM для ``cello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/x86_64/cello-1.0-1.el7.x86_64.rpm
cello.x86_64: W: invalid-url URL: https://www.example.com/cello HTTP Error 404: Not Found
cello.x86_64: W: no-documentation
cello.x86_64: W: no-manual-page-for-binary cello
1 packages and 0 specfiles checked; 0 errors, 3 warnings.
----

Наблюдения:

* Предупреждения ``no-documentation`` и ``no-manual-page-for-binary`` говорят о том, что в RPM нет документации или страниц руководства, потому что мы их не предоставили.

Помимо вышеприведенных предупреждений и ошибок, наш RPM проходит проверку ``rpmlint``.

Наши RPM теперь готовы и проверены с помощью ``rpmlint``. На этом учебное пособие заканчивается. Для получения дополнительной информации о RPM упаковке перейдите к главе
xref:advanced-topics[Дополнительные материалы].
