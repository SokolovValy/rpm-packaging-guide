[[advanced-topics]]
= Дополнительные материалы

В этой главе рассматриваются темы, которые выходят за рамки вводного руководства, но часто полезны в реальной упаковке RPM.

[[Signing-Packages]]
== Подпись пакетов

Подпись пакета - это способ защитить пакет для конечного пользователя. Безопасная транспортировка может быть достигнута с помощью реализации протокола HTTPS, что может быть сделано, когда пакет загружается непосредственно перед установкой. Однако пакеты часто загружаются заранее и хранятся в локальных репозиториях перед их использованием. Пакеты подписываются, чтобы гарантировать, что никакая третья сторона не сможет изменить содержимое пакета.

Существует три способа подписи пакета:

* xref:Adding-a-Signature-to-a-Package[Добавление подписи к уже существующему пакету].

* xref:Replacing-a-Package-Signature[Замена подписи на уже существующем пакете].

* xref:Build-time-Signing[
Подпись пакета во время сборки].

[[Adding-a-Signature-to-a-Package]]
=== Добавление подписи к пакету

В большинстве случаев пакеты создаются без подписи. Подпись добавляется непосредственно перед выпуском пакета.

Чтобы добавить другую подпись к пакету package, используйте опцию `--addsign`. Наличие более чем одной подписи позволяет зафиксировать путь владения пакетом от разработчика пакета до конечного пользователя.

В качестве примера подразделение компании создает пакет и подписывает его ключом подразделения. Затем штаб-квартира компании проверяет подпись пакета и добавляет корпоративную подпись к пакету, заявляя, что подписанный пакет является подлинным.

С двумя подписями пакеи попадает к продавцу. Продавец проверяет подписи и, если они проверяются, также добавляет свою подпись.

Теперь пакет отправляется в компанию, которая желает его развернуть. Проверив каждую подпись на упаковке, они знают, что это подлинная копия, не изменившаяся с момента ее первого создания. В зависимости от внутреннего контроля внедряющей компании, они могут добавить свою собственную подпись, чтобы заверить своих сотрудников в том, что пакет получил их корпоративное одобрение.

Вывод из команды `--addsign`:

[source,bash]
----
$ rpm --addsign blather-7.9-1.i386.rpm
            Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
----

Для проверки подписей пакета с несколькими подписями:

[source,bash]
----
$ rpm --checksig blather-7.9-1.i386.rpm
blather-7.9-1.i386.rpm: size pgp pgp md5 OK
----

Два обозначения `pgp` в выходных данных команды `rpm --checksig` показывают, что пакет был подписан дважды.

RPM позволяет добавлять одну и ту же подпись несколько раз. Параметр `--addsign`
не проверяет наличие нескольких идентичных подписей.

[source,bash]
----
$ rpm --addsig blather-7.9-1.i386.rpm
              Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
$ rpm --addsig blather-7.9-1.i386.rpm
              Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
$ rpm --addsig blather-7.9-1.i386.rpm
              Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
$ rpm --checksig blather-7.9-1.i386.rpm
blather-7.9-1.i386.rpm: size pgp pgp pgp pgp md5 OK
----

На выходе команды `rpm --checksig` отображается четыре подписи.

[[Replacing-a-Package-Signature]]
=== Замена подписи пакета 

Чтобы изменить открытый ключ без необходимости пересобирать каждый пакет, используйте опцию `--resign`.

[source,bash]
----
$ rpm --resign blather-7.9-1.i386.rpm
            Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
----

Использование опции `--resign` с несколькими пакетами:

[source,bash]
----
$ rpm --resign b*.rpm
            Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
bother-3.5-1.i386.rpm:
----

[[Build-time-Signing]]
=== Подпись во время сборки

Чтобы подписать пакет во время сборки, используйте команду `rpmbuild` с параметром `--sign`. Для этого необходимо ввести кодовую фразу PGP.

Для примера:

[source,bash]
----
$ rpmbuild -ba --sign blather-7.9.spec
            Enter pass phrase:

Pass phrase is good.
* Package: blather
…
Binary Packaging: blather-7.9-1
Finding dependencies...
…
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/blather-7.9-1.i386.rpm
…
Source Packaging: blather-7.9-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/blather-7.9-1.src.rpm
----

Сообщение "Generating signature" появляется как в двоичном, так и в исходном разделах упаковки. Число, следующее за сообщением, указывает на то, что добавленная подпись была создана с использованием  PGP.

[NOTE]
--
При использовании опции `--sign` в `rpmbuild`, используйте только аргументы `-bb` или `-ba` для сборки пакета. Аргумент `-ba` обозначает сборку бинарных *и* исходных пакетов.
--

Чтобы проверить подпись пакета, используйте `rpm` комманду `--checksig`. Для примера:

[source,bash]
----
$ rpm --checksig blather-7.9-1.i386.rpm
blather-7.9-1.i386.rpm: size pgp md5 OK
----

[[Building-Multiple-Packages]]
==== Сборка нескольких пакетов

При создании нескольких пакетов используйте следующий синтаксис, чтобы избежать многократного ввода кодовой фразы
PGP. Например, при сборки пакетов `blather` и `bother`, подпишите их, следуя примеру ниже:

[source,bash]
----
$ rpmbuild -ba --sign b*.spec
              Enter pass phrase:

Pass phrase is good.
* Package: blather
…
Binary Packaging: blather-7.9-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/blather-7.9-1.i386.rpm
…
Source Packaging: blather-7.9-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/blather-7.9-1.src.rpm
…
* Package: bother
…
Binary Packaging: bother-3.5-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/bother-3.5-1.i386.rpm
…
Source Packaging: bother-3.5-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/bother-3.5-1.src.rpm
----

ifdef::community[]
[[mock]]
== Mock

https://github.com/rpm-software-management/mock/wiki[Mock] - это инструмент для создания пакетов. Он может создавать пакеты для разных архитектур и разных версий Fedora или RHEL. Mock создает chroots и собирает в них пакеты. Его единственная задача - надежно заполнить chroot и попытаться создать пакет в этом chroot.

Mock также предлагает многопакетный инструмент `mockchain`, который может создавать цепочки пакетов, зависящих друг от друга.

Mock способен создавать Rpm из управления конфигурацией исходного кода, если присутствует пакет
`mock-scm` а затем встраивать SRPM в RPMs. Смотрите –scm-enable
в документации. (Из upstream документации)

NOTE: Чтобы использовать https://github.com/rpm-software-management/mock/wiki[Mock]
 в системе RHEL или CentOS, вам необходимо включить репозиторий “Extra Packages for
Enterprise Linux” (https://fedoraproject.org/wiki/EPEL[EPEL]) . Это репозиторий, предоставляемый сообществом https://getfedora.org/[Fedora], содержит множество полезных инструментов для пакетов RPM, системных администраторов и разработчиков.

Одним из наиболее распространенных вариантов для RPM-упаковщиков использования
https://github.com/rpm-software-management/mock/wiki[Mock] , является создание так называемой “нетронутой среды сборки”. При использовании mock в качестве “нетронутой среды сборки” ничто в текущем состоянии вашей системы не влияет на сам пакет RPM.  Mock использует различные конфигурации, чтобы указать, какова “цель” сборки, они находятся в вашей системе в каталоге``/etc/mock/`` (после установки пакета ``mock``). Вы можете выполнить сборку для разных дистрибутивов или выпусков, просто указав это в командной строке. Следует иметь в виду, что файлы конфигурации, поставляемые с макетом, предназначены для упаковщиков Fedora RPM, и поэтому выпускные версии RHEL и CentOS помечены как “epel” , потому что это «целевой» репозиторий, для которого эти RPM будут созданы. Вы просто указываете конфигурацию, которую хотите использовать (без расширения файла ``.cfg``). Например, вы можете создать наш пример ``cello`` как для RHEL 7, так и для Fedora 23, используя следующие команды, даже не используя разные машины.

[source,bash]
----
$ mock -r epel-7-x86_64 ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm

$ mock -r fedora-23-x86_64 ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm

----

Один из примеров того, почему вы можете захотеть использовать `mock` - это если вы упаковывали RPMs на своем ноутбуке, и у вас был установлен пакет (в этом примере мы назовем его ``foo``), который был ``BuildRequires`` того пакета, который вы создавали, но забыли фактически сделать запись ``BuildRequires: foo``. Сборка завершится успешно, когда вы запустите``rpmbuild`` потому что``foo`` был необходим для сборки, и он был найден в системе во время сборки. Однако, если вы перенесете SRPM в другую систему, в которой отсутствовал ``foo``, он выйдет из строя, что вызовет неожиданный побочный эффект.
https://github.com/rpm-software-management/mock/wiki[Mock] решает эту проблему, сначала анализируя содержимое  SRPM и устанавливая ``BuildRequires`` в его
https://en.wikipedia.org/wiki/Chroot[chroot] , что означает, что если бы вам не хватало записи  ``BuildRequires`` , сборка завершилась бы с ошибкой, потому что `mock` не знал бы, как её установить, и поэтому она не присутствовала бы в buildroot.

Другой пример - противоположный сценарий, допустим, вам нужен ``gcc`` для сборки пакета, но он не установлен в вашей системе (что маловероятно для RPM-упаковщика, но просто ради примера давайте притворимся, что это правда). 
С https://github.com/rpm-software-management/mock/wiki[Mock], Вам не нужно устранавливать ``gcc``в вашей системе, потому что он будет установлен в chroot как часть процесса `mock`.

Ниже приведен пример попытки перестроить пакет, у которого есть зависимость, которой мне не хватает в моей системе. Главное, что следует отметить, это то, что, хотя ``gcc`` обычно используется в большинстве систем  RPM упаковщиками, некоторые пакеты RPM могут содержать более дюжины сборочных запросов, и это позволяет вам не загромождать свою рабочую станцию ненужными или ненужными пакетами.

[source,bash]
----
$ rpmbuild --rebuild ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
Installing /home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
error: Failed build dependencies: gcc is needed by cello-1.0-1.el7.x86_64

$ mock -r epel-7-x86_64 ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
INFO: mock.py version 1.2.17 starting (python version = 2.7.5)...
Start: init plugins
INFO: selinux enabled
Finish: init plugins
Start: run
INFO: Start(/home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm)  Config(epel-7-x86_64)
Start: clean chroot
Finish: clean chroot
Start: chroot init
INFO: calling preinit hooks
INFO: enabled root cache
Start: unpacking root cache
Finish: unpacking root cache
INFO: enabled yum cache
Start: cleaning yum metadata
Finish: cleaning yum metadata
Mock Version: 1.2.17
INFO: Mock Version: 1.2.17
Start: yum update
base                                                                    | 3.6 kB  00:00:00
epel                                                                    | 4.3 kB  00:00:00
extras                                                                  | 3.4 kB  00:00:00
updates                                                                 | 3.4 kB  00:00:00
No packages marked for update
Finish: yum update
Finish: chroot init
Start: build phase for cello-1.0-1.el7.src.rpm
Start: build setup for cello-1.0-1.el7.src.rpm
warning: Could not canonicalize hostname: rhel7
Building target platforms: x86_64
Building for target x86_64
Wrote: /builddir/build/SRPMS/cello-1.0-1.el7.centos.src.rpm
Getting requirements for cello-1.0-1.el7.centos.src
 --> Already installed : gcc-4.8.5-4.el7.x86_64
 --> Already installed : 1:make-3.82-21.el7.x86_64
No uninstalled build requires
Finish: build setup for cello-1.0-1.el7.src.rpm
Start: rpmbuild cello-1.0-1.el7.src.rpm
Building target platforms: x86_64
Building for target x86_64
Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.v9rPOF
+ umask 022
+ cd /builddir/build/BUILD
+ cd /builddir/build/BUILD
+ rm -rf cello-1.0
+ /usr/bin/gzip -dc /builddir/build/SOURCES/cello-1.0.tar.gz
+ /usr/bin/tar -xf -
+ STATUS=0
+ '[' 0 -ne 0 ']'
+ cd cello-1.0
+ /usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
Patch #0 (cello-output-first-patch.patch):
+ echo 'Patch #0 (cello-output-first-patch.patch):'
+ /usr/bin/cat /builddir/build/SOURCES/cello-output-first-patch.patch
patching file cello.c
+ /usr/bin/patch -p0 --fuzz=0
+ exit 0
Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.UxRVtI
+ umask 022
+ cd /builddir/build/BUILD
+ cd cello-1.0
+ make -j2
gcc -g -o cello cello.c
+ exit 0
Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.K3i2dL
+ umask 022
+ cd /builddir/build/BUILD
+ '[' /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64 '!=' / ']'
+ rm -rf /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
++ dirname /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
+ mkdir -p /builddir/build/BUILDROOT
+ mkdir /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
+ cd cello-1.0
+ /usr/bin/make install DESTDIR=/builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
mkdir -p /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/bin
install -m 0755 cello /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/bin/cello
+ /usr/lib/rpm/find-debuginfo.sh --strict-build-id -m --run-dwz --dwz-low-mem-die-limit 10000000 --dwz-max-die-limit 110000000 /builddir/build/BUILD/cello-1.0
extracting debug info from /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/bin/cello
dwz: Too few files for multifile optimization
/usr/lib/rpm/sepdebugcrcfix: Updated 0 CRC32s, 1 CRC32s did match.
+ /usr/lib/rpm/check-buildroot
+ /usr/lib/rpm/redhat/brp-compress
+ /usr/lib/rpm/redhat/brp-strip-static-archive /usr/bin/strip
+ /usr/lib/rpm/brp-python-bytecompile /usr/bin/python 1
+ /usr/lib/rpm/redhat/brp-python-hardlink
+ /usr/lib/rpm/redhat/brp-java-repack-jars
Processing files: cello-1.0-1.el7.centos.x86_64
Executing(%license): /bin/sh -e /var/tmp/rpm-tmp.vxtAuO
+ umask 022
+ cd /builddir/build/BUILD
+ cd cello-1.0
+ LICENSEDIR=/builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/share/licenses/cello-1.0
+ export LICENSEDIR
+ /usr/bin/mkdir -p /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/share/licenses/cello-1.0
+ cp -pr LICENSE /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/share/licenses/cello-1.0
+ exit 0
Provides: cello = 1.0-1.el7.centos cello(x86-64) = 1.0-1.el7.centos
Requires(rpmlib): rpmlib(CompressedFileNames) <= 3.0.4-1 rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1
Requires: libc.so.6()(64bit) libc.so.6(GLIBC_2.2.5)(64bit) rtld(GNU_HASH)
Processing files: cello-debuginfo-1.0-1.el7.centos.x86_64
Provides: cello-debuginfo = 1.0-1.el7.centos cello-debuginfo(x86-64) = 1.0-1.el7.centos
Requires(rpmlib): rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1 rpmlib(CompressedFileNames) <= 3.0.4-1
Checking for unpackaged file(s): /usr/lib/rpm/check-files /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
Wrote: /builddir/build/RPMS/cello-1.0-1.el7.centos.x86_64.rpm
warning: Could not canonicalize hostname: rhel7
Wrote: /builddir/build/RPMS/cello-debuginfo-1.0-1.el7.centos.x86_64.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.JuPOtY
+ umask 022
+ cd /builddir/build/BUILD
+ cd cello-1.0
+ /usr/bin/rm -rf /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
+ exit 0
Finish: rpmbuild cello-1.0-1.el7.src.rpm
Finish: build phase for cello-1.0-1.el7.src.rpm
INFO: Done(/home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm) Config(epel-7-x86_64) 0 minutes 16 seconds
INFO: Results and/or logs in: /var/lib/mock/epel-7-x86_64/result
Finish: run

----

Как Вы можете видеть, `mock` - довольно подробный инструмент. Вы также заметите много выходных данных
http://yum.baseurl.org/[yum] или 
https://github.com/rpm-software-management/dnf[dnf] output (в зависимости от фиктивной цели RHEL7, CentOS7 или Fedora), которых нет в этом выводе, который был опущен для краткости и часто опускается после того, как вы выполнили ``--init`` для mock target. Например  ``mock -r epel-7-x86_64 --init`` который предварительно загрузит все необходимые пакеты, закэширует их и запустит предварительный этап сборкиchroot.

Для получения дополнительной информации, пожалуйста, обратитесь к
https://github.com/rpm-software-management/mock/wiki[Mock] upstream
документации.
endif::community[]

ifdef::community[]
[[version-control-systems]]
== Система контроля версий

При работе с RPMs,желательно использовать 
https://en.wikipedia.org/wiki/Version_control[Системы контроля версий] (VCS) такую как https://git-scm.com/[git] Следует отметить, что хранение двоичных файлов в системе контроля версий нецелесообразно, поскольку это резко увеличивает размер исходного репозитория, поскольку эти инструменты разработаны для обработки различий в файлах (часто оптимизированных для текстовых файлов) и это не то, чему поддаются бинарные файлы, поэтому обычно сохраняется весь бинарные файл целиком. В качестве побочного эффекта этого есть некоторые умные утилиты, популярные среди вышестоящих проектов с открытым исходным кодом, которые решают эту проблему, либо сохраняя файл SPEC, где исходный код находится в VCS (т. е. - он не находится в сжатом архиве для распространения ) или поместите в VCS только SPEC-файл и патчи и загрузите сжатый архив updtream исходного кода  в так называемый «кэш просмотра».

В этом разделе мы рассмотрим два различных варианта использования системы контроля версий 
https://git-scm.com/[git], для управления содержимым, которое в конечном итоге будет преобразовано в пакет RPM. Первый называется https://github.com/dgoodwin/tito[tito],
второй - https://github.com/release-engineering/dist-git[dist-git].

NOTE: Вам нужно будет установить пакет ``git`` в Вашу систему, он понадобится нам для изучения данного раздела.

[[tito]]
=== tito

- это утилита, которая предполагает, что весь исходный код программного обеспечения, которое будет упаковано, уже находится в репозитории https://git-scm.com/[git].  Это хорошо для тех, кто практикует рабочий процесс DevOps, поскольку позволяет команде, пишущей программное обеспечение, поддерживать свой нормальный
https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows[абочий процесс ветвления]. Затем Tito позволит поэтапно упаковывать программное обеспечение, создавать его в автоматическом режиме и по-прежнему обеспечивать собственный процесс установки для системы на основе RPM http://rpm.org/[RPM].

NOTE: Пакет https://github.com/dgoodwin/tito[tito] доступен в
https://getfedora.org/[Fedora], а также в репозитории 
https://fedoraproject.org/wiki/EPEL[EPEL] для использования на RHEL 7 и CentOS 7.

Tito работает на основе тегов https://git-scm.com/book/en/v2/Git-Basics-Tagging[git tags] и будет управлять тегами для вас, если вы решите разрешить это, но при желании может работать по любой схеме тегов, которую вы предпочитаете, поскольку эта функциональность настраивается.

Давайте немного познакомимся с tito, взглянув на исходный проект, который уже использует его. На самом деле мы будем использовать исходный репозиторий git проекта, который является предметом нашего следующего раздела,
https://github.com/release-engineering/dist-git[dist-git]. Поскольку этот проект публично размещен на
 https://github.com/[GitHub], давайте клонируем репозиторий git.

[source,bash]
----
$ git clone https://github.com/release-engineering/dist-git.git
Cloning into 'dist-git'...
remote: Counting objects: 425, done.
remote: Total 425 (delta 0), reused 0 (delta 0), pack-reused 425
Receiving objects: 100% (425/425), 268.76 KiB | 0 bytes/s, done.
Resolving deltas: 100% (184/184), done.
Checking connectivity... done.

$ cd dist-git/

$ ls *.spec
dist-git.spec

$ tree rel-eng/
rel-eng/
├── packages
│   └── dist-git
└── tito.props

1 directory, 2 files

----

Как мы видим, файл спецификации находится в корне репозитория git, и в репозитории есть каталог ``rel-eng``, который используется tito для общего учета, настройки и различных дополнительных тем, таких как пользовательские модули tito. В макете каталога мы видим, что есть подкаталог с названием ``packages``, в котором будет храниться файл для каждого пакета, которым tito управляет в репозитории, поскольку у вас может быть много RPM в одном репозитории git, и tito справится с этим просто отлично. Однако в этом сценарии мы видим только один список пакетов, и следует отметить, что он соответствует имени нашего файла спецификации. Все это настраивается командой ``tito init`` when the developers of
https://github.com/release-engineering/dist-git[dist-git], когда разработчики dist-git впервые инициализировали свое репозиторий git для управления tito.

Если бы мы следовали обычному рабочему процессу DevOps Practitioner, мы, вероятно, хотели бы использовать его как часть процесса
https://en.wikipedia.org/wiki/Continuous_integration[Непрерывной интеграции]
(CI) или https://en.wikipedia.org/wiki/Continuous_delivery[Непрерывной доставки]
(CD). Что мы можем сделать в этом сценарии, так это выполнить то, что известно как
“test build” для tito, мы даже можем использовать mock. Затем мы могли бы использовать выходные данные в качестве точки установки для какого-либо другого компонента в конвейере. Ниже приведен простой пример команд, которые могут это сделать, и их можно адаптировать к другим средам.

[source,bash]
----
$ tito build --test --srpm
Building package [dist-git-0.13-1]
Wrote: /tmp/tito/dist-git-git-0.efa5ab8.tar.gz

Wrote: /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.fc23.src.rpm

$ tito build --builder=mock --arg mock=epel-7-x86_64 --test --rpm
Building package [dist-git-0.13-1]
Creating rpms for dist-git-git-0.efa5ab8 in mock: epel-7-x86_64
Wrote: /tmp/tito/dist-git-git-0.efa5ab8.tar.gz

Wrote: /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.fc23.src.rpm

Using srpm: /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.fc23.src.rpm
Initializing mock...
Installing deps in mock...
Building RPMs in mock...
Wrote:
  /tmp/tito/dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm
  /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm

$ sudo yum localinstall /tmp/tito/dist-git-*.noarch.rpm
Loaded plugins: product-id, search-disabled-repos, subscription-manager
Examining /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm: dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch
Marking /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm to be installed
Examining /tmp/tito/dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm: dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch
Marking /tmp/tito/dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm to be installed
Resolving Dependencies
--> Running transaction check
---> Package dist-git.noarch 0:0.13-1.git.0.efa5ab8.el7.centos will be installed

----

Обратите внимание, что последняя команда должна быть запущена либо с правами sudo, либо с правами root, и что большая часть выходных данных была опущена для краткости, поскольку список зависимостей довольно длинный.

На этом наш простой пример использования tito заканчивается, но в нем есть много удивительных функций для традиционных системных администраторов, разработчиков RPM-пакетов и практиков DevOps. Я бы настоятельно рекомендовал ознакомиться с upstream документацией, найденной на сайте _tito_ GitHub, для получения дополнительной информации о том, как быстро начать использовать его для вашего проекта, а также о различных дополнительных функциях, которые он предлагает.

[[dist-git]]
=== dist-git

Утилита  https://github.com/release-engineering/dist-git[dist-git] использует несколько иной подход, чем у
 https://github.com/dgoodwin/tito[tito],
так что вместо того, чтобы хранить upstream исходный код в https://git-scm.com/[git], она вместо этого будет хранить файлы спецификаций и патчи в репозитории git и загружать сжатый архив исходного кода в так называемый “look-aside cache”.
“Look-aside-cache” - это термин, который был придуман при использовании систем сборки RPM, хранящих большие файлы, подобные этим, “на стороне”. Подобная система, как правило, привязана к правильной системе сборки RPM, такой как  https://pagure.io/koji[Koji].
Затем система сборки настраивается на извлечение элементов, которые перечислены в качестве записей
``SourceX`` в файлах спецификаций, из этого внешнего кэша, в то время как спецификация и исправления остаются в системе контроля версий. Существует также вспомогательный инструмент командной строки, который поможет в этом.

Чтобы не дублировать документацию, для получения дополнительной информации о том, как настроить такую систему, пожалуйста, обратитесь к upstream документации
https://github.com/release-engineering/dist-git[dist-git].
endif::community[]

[[more-on-macros]]
== Подробнее о макросах

Существует множество встроенных макросов RPM, и мы рассмотрим некоторые из них в следующем разделе, однако исчерпывающий список можно найти на странице
https://rpm-software-management.github.io/rpm/manual/macros.html[RPM Official Documentation].

ifdef::community[]
Существуют также макросы, предоставляемые вашим дистрибутивом
https://en.wikipedia.org/wiki/Linux[Linux] D, в этом разделе мы рассмотрим некоторые из них, предоставляемые
those provided by https://getfedora.org/[Fedora],
https://www.centos.org/[CentOS] и
https://www.redhat.com/en/technologies/linux-platforms[RHEL], а также предоставим информацию о том, как проверить вашу систему, чтобы узнать о других, которые мы не рассматриваем, или для их обнаружения в других дистрибутивах Linux на основе RPM
endif::community[]

ifdef::rhel[]
Существуют также макросы, предоставляемые Red Hat Enterprise Linux, некоторые из
которые мы рассмотрим в этом разделе. Мы также узнаем, как проверить вашу систему, чтобы узнать
о других макросах.
endif::rhel[]

[[defining-your-own]]
=== Определение Ваших Собственных Макросов

Вы можете определить свои собственные макросы. Ниже приводится выдержка из
https://rpm-software-management.github.io/rpm/manual/macros.html[RPM Official Documentation],  в которой содержится исчерпывающая информация о возможностях макросов.

Чтобы определить макрос, используйте:

[source,specfile]
----
%global <name>[(opts)] <body>
----

Все пробелы, окружающие  ``\ ``, удаляются.  Имя может состоять из буквенно-цифровых символов и символа `_`  и должно иметь длину не менее 3 символов. A
Макрос без поля `(opts)` является “простым” в том смысле, что выполняется только рекурсивное расширение макроса. Параметризованный макрос содержит поле `(opts)` field. The
`opts` - (строка в круглых скобках) передается точно так же, как и в getopt(3)  для обработки
argc/argv  в начале вызова макроса.

[NOTE]
--
Более старые файлы спецификаций RPM могут использовать шаблон макроса `%define <name> <body>`. Различия между макросами `%define` и `%global` заключаются в следующем:

* `%define` имеет локальную область действия, что означает, что он применяется только к указанной части SPEC файла. IКроме того, тело макроса  `%define` расширяется при использовании.
* `%global` имеет глобальную область действия, что означает, что он применяется ко всему SPEC файлу.
Кроме того, тело макроса `%global` асширяется во время определения.
--

Пример:

----
%global githash 0ec4e58
%global python_sitelib %(%{__python} -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())")
----

NOTE: MМакросы всегда оцениваются, даже в комментариях. Иногда это безобидно. Но во втором примере мы выполняем команду python, чтобы получить содержимое макроса. Эта команда будет выполняться даже тогда, когда вы закомментируете макрос. Или когда вы вводите имя макроса в%changelog. Чтобы закомментировать макрос, используйте 
`%%`. Например: `%%global`.

[[setup]]
=== %setup

Макрос  ``%setup`` ожно использовать для сборки пакета с помощью tarball исходного кода.
Стандартное поведение макроса ``%setup`` можно увидеть в выходных данных ``rpmbuild``.
В начале каждой фазы макрос выводит ``Executing(%something)``.
Например:

[source,bash]
----
Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.DhddsG
----

Выходные данные оболочки устанавливаются с включенным ``set -x``. Чтобы просмотреть содержимое 
``/var/tmp/rpm-tmp.DhddsG``, используйте опцию ``--debug``, поскольку ``rpmbuild`` удаляет временные файлы после успешной сборки. Здесь отображается настройка переменных среды, например:

[source,bash]
----
cd '/builddir/build/BUILD'
rm -rf 'cello-1.0'
/usr/bin/gzip -dc '/builddir/build/SOURCES/cello-1.0.tar.gz' | /usr/bin/tar -xof -
STATUS=$?
if [ $STATUS -ne 0 ]; then
  exit $STATUS
fi
cd 'cello-1.0'
/usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
----

Макрос ``%setup`` гарантирует, что мы работаем в правильном каталоге, удаляет остатки предыдущих сборок, распаковывает исходный архив и устанавливает некоторые привилегии по умолчанию. Существует несколько вариантов настройки поведения макроса 
``%setup``.

[[setup-q]]
==== %setup -q

Параметр ``-q``  ограничивает детализацию макроса  ``%setup``. Вместо ``tar -xof`` выполняется только ``tar -xvvof``. Этот параметр должен быть использован в качестве первого.

[[setup-n]]
==== %setup -n

В некоторых случаях каталог из расширенного архива имеет другое имя, чем ожидалось ``%{name}-%{version}``. Это может привести к ошибке макроса ``%setup``.  Имя каталога должно быть указано параметром ``-n directory_name``.

Например, если имя пакета  ``cello``, , но исходный код заархивирован в ``hello-1.0.tgz`` и содержит каталог ``hello/`` содержимое SPEC файла должно быть:

[source,specfile]
----
Name: cello
Source0: https://example.com/%{name}/release/hello-%{version}.tar.gz
…
%prep
%setup -n hello
----

[[setup-c]]
==== %setup -c

Параметр  ``-c`` можно использовать, если архив исходного кода не содержит никаких подкаталогов и после распаковки файлы из архива заполняют текущий каталог. Опция ``-c`` создает каталог и переходит к расширению архива. Наглядный пример:

[source,bash]
----
/usr/bin/mkdir -p cello-1.0
cd 'cello-1.0'
----

Каталог не изменяется после расширения архива.

[[setup-dt]]
==== %setup -D and -T

``-D``  отключает удаление каталога исходного кода. Этот параметр полезен, если макрос ``%setup`` mиспользуется несколько раз. По сути, параметр ``-D`` означает, что сделующие строки не используются:

[source,bash]
----
rm -rf 'cello-1.0'
----

Параметр``-T`` отключает расширение хранилища исходного кода, удаляя следующую строку из скрипта:

[source,bash]
----
/usr/bin/gzip -dc '/builddir/build/SOURCES/cello-1.0.tar.gz' | /usr/bin/tar -xvvof -
----

[[setup-ab]]
==== %setup -a and -b

Параметры ``-a`` и ``-b`` расширяют определённые источники.

* Параметр ``-b`` (расшифровывается как `before`) расширяет определенные источники перед входом в рабочий каталог.
* Параметр ``-a`` (расшифровывается как  `after`) расширяет эти источники после входа. Их аргументами являются исходные номера из преамбулы файла спецификации.

Например, допустим, что ``cello-1.0.tar.gz`` архив содержит пустой каталог ``examples``, и примеры поставляются в отдельных
``examples.tar.gz`` tarball, и они разархивируются в каталог с тем же именем. В этом случае используйте ``-a 1``, так как мы хотим разархивировать ``Source1`` после входа в рабочий каталог:

[source,specfile]
----
Source0: https://example.com/%{name}/release/%{name}-%{version}.tar.gz
Source1: examples.tar.gz
…
%prep
%setup -a 1
----

Но если бы примеры были в отдельном ``cello-1.0-examples.tar.gz`` tarball,
который расширяется до ``cello-1.0/examples``, используйте параметры ``-b 1``, поскольку 
``Source1`` должен быть разархивирован перед входом в рабочий каталог:

[source,specfile]
----
Source0: https://example.com/%{name}/release/%{name}-%{version}.tar.gz
Source1: %{name}-%{version}-examples.tar.gz
…
%prep
%setup -b 1
----

Вы также можете использовать комбинацию всех этих опций.

[[files]]
=== %files

Общие  “расширенные” макросы RPM, необходимые в разделе ``%files``:

[cols="20%,80%"]
|====
| Макрос             | Описание
| %license           | Это идентифицирует файл, указанный в списке как файл ЛИЦЕНЗИИ, и он будет установлен и помечен как таковой RPM. Пример: ``%license LICENSE``
| %doc               | TЭто идентифицирует файл, указанный как документация, и он будет установлен и помечен RPM как таковой. Это часто используется не только для документации об упаковываемом программном обеспечении, но и для примеров кода и различных элементов, которые должны сопровождать документацию. Пример: ``%doc README``
| %dir               | Указывает, что путь является каталогом, которым должен владеть этот RPM. Это важно, чтобы манифест RPM-файла точно знал, какие каталоги очищать при удалении. Пример: ``%dir %{_libdir}/%{name}``
| %config(noreplace) | Указывает, что следующий файл является файлом конфигурации и поэтому не должен перезаписываться (или заменяться) при установке или обновлении пакета, если файл был изменен по сравнению с исходной контрольной установкой. В случае внесения изменений файл будет создан с добавлением ``.rpmnew`` в конец имени файла при обновлении или установке, чтобы ранее существующий или измененный файл в целевой системе не был изменен. Пример: ``%config(noreplace) %{_sysconfdir}/%{name}/%{name}.conf``
|====

[[built-in-macros]]
=== Встроенные макросы

В вашей системе есть много встроенных макросов RPM, и самый быстрый способ просмотреть их все - это просто выполнить команду ``rpm --showrc``. Обратите внимание, что это будет содержать много выходных данных, поэтому его часто используют в сочетании с каналом для `grep`.

Вы также можете найти информацию о макросах RPM, которые поставляются непосредственно с версией RPM вашей системы, просмотрев выходные данные   ``rpm -ql rpm`` , обратив внимание на файлы с названием ``macros`` в структуре каталогов.  

[[rpm-distribution-macros]]
=== RPM Distribution Macros

Различные дистрибутивы будут предоставлять разные наборы рекомендуемых макросов RPM в зависимости от языковой реализации упаковываемого программного обеспечения или конкретных рекомендаций рассматриваемого дистрибутива.

ifdef::community[]
Они часто предоставляются в виде самих пакетов RPM и могут быть установлены с пакетного менеджера, такого как http://yum.baseurl.org/[yum] или
https://github.com/rpm-software-management/dnf[dnf]. Сами файлы макросов после установки можно найти в ``/usr/lib/rpm/macros.d/`` и они будут включены в вывод ``rpm --showrc`` по умолчанию после установки.
endif::community[]

ifdef::rhel[]
Они часто предоставляются в виде самих пакетов RPM и могут быть установлены с пакетного менеджера, такого как http://yum.baseurl.org/[yum] или
https://github.com/rpm-software-management/dnf[dnf]. Сами файлы макросов после установки можно найти в ``/usr/lib/rpm/macros.d/`` и они будут включены в вывод ``rpm --showrc`` по умолчанию после установки.
endif::rhel[]

Одним из основных примеров этого является раздел
https://docs.fedoraproject.org/en-US/packaging-guidelines/[Fedora Packaging
Guidelines] относящийся конкретно к
https://docs.fedoraproject.org/en-US/packaging-guidelines/_domain_specific_guidelines[Application
Specific Guidelines], который на момент написания этой статьи содержит более 60 различных наборов руководств вместе с соответствующими наборами макросов RPM для конкретной упаковки RPM.

ifdef::community[]
Одним из примеров такого рода RPM может быть для  https://www.python.org/[Python]
версии 2.x, и если у нас установлен пакет ``python2-rpm-macros`` 
(доступный в EPEL для RHEL 7 и CentOS 7), у нас есть ряд доступных нам специфичных для python2 макросов.
endif::community[]

ifdef::rhel[]
Одним из примеров такого рода RPM может быть для  https://www.python.org/[Python]
версии 2.x, и если у нас установлен пакет ``python2-rpm-macros`` 
(доступный в EPEL для RHEL 7 и CentOS 7), у нас есть ряд доступных нам специфичных для python2 макросов.
endif::rhel[]

[source,bash]
----
$ rpm -ql python2-rpm-macros
/usr/lib/rpm/macros.d/macros.python2

$ rpm --showrc | grep python2
-14: __python2  /usr/bin/python2
CFLAGS="%{optflags}" %{__python2} %{py_setup} %{?py_setup_args} build --executable="%{__python2} %{py2_shbang_opts}" %{?1}
CFLAGS="%{optflags}" %{__python2} %{py_setup} %{?py_setup_args} install -O1 --skip-build --root %{buildroot} %{?1}
-14: python2_sitearch   %(%{__python2} -c "from distutils.sysconfig import get_python_lib; print(get_python_lib(1))")
-14: python2_sitelib    %(%{__python2} -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())")
-14: python2_version    %(%{__python2} -c "import sys; sys.stdout.write('{0.major}.{0.minor}'.format(sys.version_info))")
-14: python2_version_nodots     %(%{__python2} -c "import sys; sys.stdout.write('{0.major}{0.minor}'.format(sys.version_info))")

----

В приведенном выше выводе отображаются необработанные определения макросов RPM, но нас, вероятно, больше интересует, что они будут оценивать, что мы можем сделать с помощью ``rpm --eval`` , чтобы определить, что они делают, а также как они могут быть полезны для нас при упаковке RPMs.

[source,bash]
----
$ rpm --eval %{__python2}
/usr/bin/python2

$ rpm --eval %{python2_sitearch}
/usr/lib64/python2.7/site-packages

$ rpm --eval %{python2_sitelib}
/usr/lib/python2.7/site-packages

$ rpm --eval %{python2_version}
2.7

$ rpm --eval %{python2_version_nodots}
27

----

[[custom-macros]]
== Пользовательские макросы

Вы можете переопределить макросы в файле ``~/.rpmmacros``. Любые внесенные вами изменения повлияют на каждую сборку на вашем компьютере.

Существует несколько макросов, которые Вы можете использовать для переопределения::

``%_topdir /opt/some/working/directory/rpmbuild``:: Вы можете создать этот каталог, включая все подкаталоги, с помощью утилиты ``rpmdev-setuptree``.
Значение этого макроса по умолчанию равно``~/rpmbuild``.

``%_smp_mflags -l3``:: Этот макрос часто используется для передачи в Makefile, например 
``make %{?_smp_mflags}``, и для задания количества одновременных процессов на этапе сборки. По умолчанию для него задано значение ``-jX``, где X - количество ядер. Если вы измените количество ядер, Вы можете ускорить или замедлить сборку пакетов.

Хотя Вы можете определить любые новые макросы в файле ``~/.rpmmacros``  это не рекомендуется, поскольку эти макросы не будут присутствовать на других компьютерах, гд е пользователи могут захотеть попытаться пересобрать Ваш пакет.

[[epoch-scriptlets-and-triggers]]
== Epoch, Scriptlets, and Triggers

В мире SPEC бфайлов  RPM существуют различные разделы, которые считаются продвинутыми, поскольку они влияют не только на файл спецификации, способ сборки пакета, но и на конечный компьютер, на который устанавливается результирующий RPM. В этом разделе мы рассмотрим наиболее распространенные из них, такие как Epoch, Скриптлеты и триггеры.

[[epoch]]
=== Epoch

Первым в списке стоит ``Epoch``, epoch - это способ определения взвешенных зависимостей на основе номеров версий. Его значение по умолчанию равно 0, и это предполагается, если директива 
``Epoch``  не указана в SPEC файле. Это не рассматривалось в разделе "SPEC файл" этого руководства, потому что почти всегда вводить значени Epoch  - плохая идея, поскольку это искажает то, что вы обычно ожидаете от RPM при сравнении версий пакетов.

Например, если был установлен пакет ``foobar`` с ``Epoch: 1`` и ``Version: 1.0``, а кто-то другой упаковал ``foobar`` с``Version: 2.0`` , но просто опустил директиву ``Epoch`` либо потому, что они не знали о ее необходимости, либо просто забыли, эта новая версия никогда не будет считаться обновлением, потому что версия Epoch превалирует над традиционным маркером
Name-Version-Release, который означает управление версиями для RPM-пакетов.

Этот подход обычно используется только в случае крайней необходимости (в крайнем случае) для решения проблемы с порядком обновления, которая может возникнуть как побочный эффект upstream программного обеспечения, изменяющего схемы нумерации версий или версии, включающие буквенные символы, которые не всегда можно надежно сравнить на основе кодирование.

[[triggers-and-scriptlets]]
=== Scriptlets and Triggers

В пакетах RPM существует ряд директив, которые можно использовать для внесения необходимых или желаемых изменений в систему во время установки RPM. Они называются **scriptlets**.

Один из основных примеров того, когда и почему вы хотели бы это сделать, - это когда установлена системная служба RPM и она предоставляет 
https://freedesktop.org/wiki/Software/systemd/[systemd]
https://www.freedesktop.org/software/systemd/man/systemd.unit.html[файл].
Во время установки нам нужно будет уведомить
https://freedesktop.org/wiki/Software/systemd/[systemd]  о появлении нового модуля, чтобы системный администратор мог выполнить команду, аналогичную  ``systemctl start
foo.service`` после установки вымышленного ``foo`` (который в этом примере предоставляет демон). Аналогично, нам нужно было бы отменить это действие при деинсталляции, чтобы администратор не получал ошибок из-за того, что двоичный файл демона больше не установлен, но файл модуля все еще существует в запущенной конфигурации systemd.

Существует небольшая горстка распространенных директив скриптлета, они похожи на “заголовки разделов”, такие как ``%build`` or ``%install``, в том смысле, что они определяются многострочными сегментами кода, часто написанными как стандартный сценарий оболочки
ifdef::community[https://en.wikipedia.org/wiki/POSIX[POSIX]]
ifdef::rhel[POSIX]
, но могут быть на нескольких разных языках программирования, так что RPM для дистрибутива целевой машины настроен таким образом, чтобы они разрешались. A
Исчерпывающий список этих доступных языков можно найти в _Официальной документации RPM_.

Следующие скриптлет директивы:

[cols="20%,80%"]
|====
| Директива   | Описание
| ``%pre``    | Скриптлет, который выполняется непосредственно перед установкой пакета в целевую систему.
| ``%post``   | Скриптлет, который выполняется сразу после установки пакета в целевой системе.
| ``%preun``  | Скриптлет, который выполняется непосредственно перед удалением пакета из целевой системы.
| ``%postun`` | Скриптлет, который выполняется сразу после удаления пакета из целевой системы.
|====

Также часто для этой функции существуют макросы RPM.  В нашем предыдущем примере мы обсуждали необходимость получения  https://freedesktop.org/wiki/Software/systemd/[systemd]
уведомления о новом
https://www.freedesktop.org/software/systemd/man/systemd.unit.html[unit file],
, это легко обрабатывается макросами скриптлета systemd, как мы можем видеть из приведенного ниже примера вывода.  Более подробную информацию об этом можно найти в
https://fedoraproject.org/wiki/Packaging:Systemd[Fedora systemd Packaging
Guidelines].

[source,bash]
----
$ rpm --showrc | grep systemd
-14: __transaction_systemd_inhibit      %{__plugindir}/systemd_inhibit.so
-14: _journalcatalogdir /usr/lib/systemd/catalog
-14: _presetdir /usr/lib/systemd/system-preset
-14: _unitdir   /usr/lib/systemd/system
-14: _userunitdir       /usr/lib/systemd/user
/usr/lib/systemd/systemd-binfmt %{?*} >/dev/null 2>&1 || :
/usr/lib/systemd/systemd-sysctl %{?*} >/dev/null 2>&1 || :
-14: systemd_post
-14: systemd_postun
-14: systemd_postun_with_restart
-14: systemd_preun
-14: systemd_requires
Requires(post): systemd
Requires(preun): systemd
Requires(postun): systemd
-14: systemd_user_post  %systemd_post --user --global %{?*}
-14: systemd_user_postun        %{nil}
-14: systemd_user_postun_with_restart   %{nil}
-14: systemd_user_preun
systemd-sysusers %{?*} >/dev/null 2>&1 || :
echo %{?*} | systemd-sysusers - >/dev/null 2>&1 || :
systemd-tmpfiles --create %{?*} >/dev/null 2>&1 || :

$ rpm --eval %{systemd_post}

if [ $1 -eq 1 ] ; then
        # Initial installation
        systemctl preset  >/dev/null 2>&1 || :
fi

$ rpm --eval %{systemd_postun}

systemctl daemon-reload >/dev/null 2>&1 || :

$ rpm --eval %{systemd_preun}

if [ $1 -eq 0 ] ; then
        # Package removal, not upgrade
        systemctl --no-reload disable  > /dev/null 2>&1 || :
        systemctl stop  > /dev/null 2>&1 || :
fi

----

Еще один элемент, который обеспечивает еще более детальный контроль над транзакцией RPM в целом, - это то, что известно как **триггеры**. По сути, это то же самое, что и скриптлет, но выполняется в очень определенном порядке операций во время транзакции установки или обновления RPM, что позволяет более точно контролировать весь процесс.    

Порядок, в котором выполняется каждый из них, и подробная информация о котором приведена ниже.

[source,specfile]
----
all-%pretrans
...
any-%triggerprein (%triggerprein from other packages set off by new install)
new-%triggerprein
new-%pre      for new version of package being installed
...           (all new files are installed)
new-%post     for new version of package being installed

any-%triggerin (%triggerin from other packages set off by new install)
new-%triggerin
old-%triggerun
any-%triggerun (%triggerun from other packages set off by old uninstall)

old-%preun    for old version of package being removed
...           (all old files are removed)
old-%postun   for old version of package being removed

old-%triggerpostun
any-%triggerpostun (%triggerpostun from other packages set off by old un
            install)
...
all-%posttrans

----

ifdef::community[]
Вышеуказанные элементы взяты из прилагаемой документации RPM, найденной в
``/usr/share/doc/rpm/triggers`` на системах Fedora и
``/usr/share/doc/rpm-4.*/triggers`` в системах RHEL 7 и CentOS 7.
endif::community[]

ifdef::rhel[]
The above items are from the included RPM documentation found in
``/usr/share/doc/rpm-4.*/triggers``.
endif::rhel[]

[id="Using-Non-Shell-Scripts-in-spec-File"]
==== Using Non-Shell Scripts in SPEC File

Параметр скриптлета `-p`, в SPEC файле позволяет вызывать определенный интерпретатор вместо стандартного `-p{nbsp}/bin/sh`. аглядным примером является скрипт, который выводит сообщение после установки `pello.py`.

. Откройте файл `pello.spec`.

. Найдите следующую строку:
+
[source,specfile]
----
install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/
----
+
Под этой строкой вставьте следующий код:
+
[source,specfile]
----
%post -p /usr/bin/python3
print("This is {} code".format("python"))
----

. Создайте свой пакет в соответствии с главой xref:building-rpms[Сборка RPMS].

ifdef::community[]
. Установите Ваш пакет:
+
[source,bash]
----
# dnf install /home/<username>/rpmbuild/RPMS/noarch/pello-0.1.1-1.fc27.noarch.rpm
----
+
Результатом выполнения этой команды является следующее сообщение после установки:
+
[source]
----
Installing       : pello-0.1.1-1.fc27.noarch                              1/1
Running scriptlet: pello-0.1.1-1.fc27.noarch                              1/1
This is python code
----
endif::community[]

ifdef::rhel[]
. Install your package:
+
[source,bash]
----
# yum install /home/<username>/rpmbuild/RPMS/noarch/pello-0.1.1-1.fc27.noarch.rpm
----
+
The output of this command is the following message after the installation:
+
[source]
----
Installing       : pello-0.1.1-1.fc27.noarch                              1/1
Running scriptlet: pello-0.1.1-1.fc27.noarch                              1/1
This is python code
----
endif::rhel[]

[NOTE]
--
* Чтобы использовать скрипт  Python{nbsp}3: Напишите строку `%post -p /usr/bin/python3`  под строкой `install -m` in a SPEC file.

* Чтобы использовать крипт Lua: Напишите строку `%post -p <lua>` под строкой
`install{nbsp}-m` in a SPEC file.

* Таким образом, в SPEC файле может быть указан любой интерпретатор. 
--

[[rpm-conditionals]]
== Условные обозначения RPM 

Условные обозначения RPM позволяют условно включать различные разделы SPEC файла.

Чаще всего условные обозначения имеют дело с:

* разделами, относящимся к конкретной архитектуре
* разделами, относящимся к конкретной операционной системе
* проблемами совместимости между различными версиями операционных систем
* существованием и определением макросов

=== RPM Conditionals Syntax

Если _выражение_ истинно, то выполните какое-нибудь действие:

  %if expression
  ...
  %endif

Если _выражение_ истинно, то выполните какое-нибудь действие, в другом случае выполните другое действие:

  %if expression
  ...
  %else
  ...
  %endif

// If _expression_ is not true, then do some action.

//  %if !expression
//   ...
//   %endif

// If _expression_ is not true, then do some action, in other case, do another action.

//  %if !expression
//  ...
//  %else
//  ...
//  %endif

=== Примеры условных обозначений RPM

==== Обозначение `%if` 

  %if 0%{?rhel} == 6
  sed -i '/AS_FUNCTION_DESCRIBE/ s/^/#/' configure.in
  sed -i '/AS_FUNCTION_DESCRIBE/ s/^/#/' acinclude.m4
  %endif

Это условие обрабатывает совместимость между  RHEL6 и другими операционными системами с точки зрения поддержки макроса AS_FUNCTION_DESCRIBE. Когда пакет создается для RHEL, определяется макрос `%rhel` , и он расширяется до версии RHEL. Если его значение равно 6, что означает, что пакет создан для RHEL 6, , то ссылки на
AS_FUNCTION_DESCRIBE, который не поддерживается RHEL6,  удаляются из сценариев автоконфигурации.

ifdef::community[]
  %if 0%{?el6}
  %global ruby_sitearch %(ruby -rrbconfig -e 'puts Config::CONFIG["sitearchdir"]')
  %endif

Это условие регулирует совместимость между Fedora версии 17 и новее и RHEL 6 с точки зрения поддержки макроса  `%ruby_sitearch` macro. . Fedora версии 17 и никогда не определяет `%ruby_sitearch` bпо умолчанию, но RHEL6 не поддерживает этот макрос. Условие проверяет, является ли операционная система RHEL 6. Если это так,
`%ruby_sitearch` определяется явно. Обратите внимание, что  `0%{?el6}` имеет то же значение, что и `0%{?rhel} == 6` из предыдущего примера, и он проверяет, построен ли пакет на RHEL 6.
endif::community[]

ifdef::community[]
  %if 0%{?fedora} >= 19
  %global with_rubypick 1
  %endif

Это условие обрабатывает поддержку инструмента выбора ruby. Если операционная система Fedora версии 19 или новее, поддерживается rubypick.
endif::community[]

  %define ruby_archive %{name}-%{ruby_version}
  %if 0%{?milestone:1}%{?revision:1} != 0
  %define ruby_archive %{ruby_archive}-%{?milestone}%{?!milestone:%{?revision:r%{revision}}}
  %endif

Это условие обрабатывает определение макросов. Если заданы макросы `%milestone` или
`%revision`, переопределяется макрос `%ruby_archive`, который определяет имя вышестоящего файла архива.

==== Специальные варианты обозначения `%if`

Условные обозначения `%ifarch`, `%ifnarch` и `%ifos` являются специализированными вариантами условных обозначений `%if`. Эти варианты обычно используются, поэтому у них есть свои собственные макросы.

===== Обозначение`%ifarch` 

Условие `%ifarch` спользуется для начала блока файла спецификации, который зависит от архитектуры. За ним следует один или несколько спецификаторов архитектуры, каждый из которых разделен запятыми или пробелами.

  %ifarch i386 sparc
  ...
  %endif

Все содержимое SPEC файла между `%ifarch` и `%endif` обрабатывается только на 32-разрядных архитектурах AMD и Intel или системах на базе Sun SPARC.

===== Условное обозначение `%ifnarch`

Условие `%ifnarch` cимеет обратную логику, чем условие  `%ifarch`.

  %ifnarch alpha
  ...
  %endif

Все содержимое SPEC файла между `%ifnarch` и `%endif` обрабатывается только в том случае, если это не выполняется в системе на основе Digital Alpha/AXP.


===== Условие `%ifos` 

Условие `%ifos`  используется для управления обработкой на основе операционной системы сборки. За ним может следовать одно или несколько имен операционной системы.

  %ifos linux
  ...
  %endif

Все содержимое файла спецификации между `%ifos` и `%endif` обрабатывается только в том случае, если сборка была выполнена в системе Linux.
